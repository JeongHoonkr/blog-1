#스레드 안전성
스레드에 안전한 코드를 작성하는 것은 근본적으로는 상태, 특히 공유되고 변경할 수 있는 상태에 대한 접근을 관리하는 것이다.<br>

공유됐다는 것은 여러 스레드가 특정 변수에 접근할 수 있다는 뜻이고, 변경할 수 있다(mutable)는 것은 해당 변수 값이 변경될 수 있다는 뜻이다. **스레드 안전성이 마치 코드를 보호하는 것처럼 이해하는 경우가 많지만, 실제로는 데이터에 제어 없이 동시 접근하는 걸 막으려는 의미임을 알아두자.**<br>

자바에서 동기화를 위한 기본 수단은 synchronized 키워드로서 배타적인 락을 통해 보호 기능을 제공한다. 하지만 volatile 변수, 명시적 락, 단일 연산 변수(atomic variable)를 사용하는 경우에도 '동기화'라는 용어를 사용한다.<br>

##스레드 안전성이란?
스레드 안전하지 않은 클래스와 안전한 클래스는 어떻게 구분할까? 또 '안전하다'는 것은 무든 뜻일까? 스레드에 대한 납득할 만한 정의의 핵심은 모두 정확성(correctness) 개념과 관계 있다. 스레드 안전성에 대한 정의가 모호한 것은 정확성에 대한 명확한 정의가 없기 때문이다.<br>

정확성이란 클래스가 해당 클래스의 명세에 부합한다는 뜻이다. 잘 작성된 클래스 명세는 객체 상태를 제약하는 불변조건(invariants)과 연산 수행 후 효과를 기술하는 후조건(postcondition)을 정의한다. 하지만 종종 클래스에 대한 명세를 충분히 작성하지 않는 상황에서 과연 작성한 코드가 클래스 명세에 부합하는지 알 수 있을까? 물론 알 수 없다. 하지만 일단 "특정 코드가 동작한다"고 확신하기만 하면 어쨌든 명세를 활용하지 못할 것도 없다. 이런 '코드 신뢰도'는 많은 사람이 생각하는 정확성과 대략 일치한다. 이런 맥락에서 단일 스레드에서의 정확성은 '척 보면 아는' 어떤 것이라고 가정하자. 낙관적으로 '정확성'을 인지할 수 있는 어떤 것으로 정의하면 스레드 안전성도 다소 덜 순환적으로  정의할 수 있다. 즉 여러 스레드가 클래스에 접근할 때 계속 정확하게 동작하면 해당 클래스는 스레드 안전하다.<br>

예제 : 상태 없는 서블릿
```
@ThreadSafe
public class StatelessFactorizer implements Servlet {
    public void service(ServletRequest req, ServletResponse resp) {
        BigInteger i = extractFromRequest(req);
        BigInteger[] factors = factor(i);
        encodeIntoResponse(resp, factors);
    }
}
```
#객체 공유

#객체 구성

#구성 단위