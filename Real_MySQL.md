# Real MySQL
## 5장 인덱스
### 랜덤 I/O와 순차 I/O
랜덤 I/O라는 표현은 디스크 드라이브의 플래터(원판)를 돌려서 읽어야 할 데이터가 저장된 위치로 디스크 헤더를 이동시킨 다음 데이터를 읽는 것을 의미하는데,
사실 순차 I/O 또한 이 작업은 같다. 그렇다면 어떤 차이가 있을까?

3개의 페이지(16 * 3KB)를 디스크에 기록하기 위해서 순차 I/O는 1번 시스템 콜을 요청하지만, 랜덤 I/O는 3번 시스템 콜을 요청한다.
즉, 디스크에 기록해야 할 위치를 찾기 위해 순차 I/O는 디스크의 헤드를 1번 움직였고 랜덤 I/O는 디스크 헤드를 3번 움직인 것이다. 결국 순차 I/O가 랜덤 I/O보다
거의 3배 정도 빠르다고 볼 수 있다.

일반적으로 쿼리를 튜닝하는 것은 랜덤 I/O 자체를 줄여주는 것이 목적이라고 할 수 있다. 여기서 랜덤 I/O를 줄인다는 것은 쿼리를 처리하는 데 꼭 필요한 데이터만
읽도록 쿼리를 개선하는 것을 의미한다.

인덱스 레인지 스캔은 데이터를 읽기 위해 주로 랜덤 I/O를 사용하며, 풀 테이블 스캔은 순차 I/O를 사용한다. 그래서 큰 테이블의 레코드 대부분을 읽는 작업에서는
인덱스를 사용하지 않고 풀 테이블 스캔을 사용하도록 유도할 때도 있다. 이는 순차 I/O가 랜덤 I/O보다 훨씬 빨리 많은 레코드를 읽어올 수 있기 때문인데, 이런 형태는
OLTP(Online Transaction Processing) 성격의 웹 서비스보다는 데이터 웨어하우스나 통계 작업에서 자주 사용된다.

### 인덱스란?
DBMS의 인덱스도 SortedList와 마찬가지로 저장되는 칼럼의 값을 이용해 항상 정렬된 상태로 유지한다. 데이터 파일은 ArrayList와 같이 저장된 순서대로
별도의 정렬 없이 그대로 저장해 둔다.

결론적으로 DBMS에서 인덱스는 데이터의 저장(insert, update, delete) 성능을 희생하고 그 대신 데이터의 읽기(select) 속도를 높이는 기능이다.
테이블의 인덱스를 하나 더 추가할지 말지는 데이터의 저장 속도를 어디까지 희생할 수 있는지, 읽기 속도를 얼마나 더 빠르게 만들어야 하는지의 여부에 따라
결정돼야 한다.

인덱스를 통해 테이블의 레코드를 읽는 것은 인덱스를 거치지 않고 바로 테이블의 레코드를 읽는 것보다 높은 비용이 드는 작업이다. 테이블의 레코드가 100만 건이
저장돼 있는데, 그중에서 50만 건을 읽어야 하는 쿼리가 있다고 가정해 보자. 이 작업은 전체 테이블을 모두 읽어서 필요 없는 50만 건을 버리는 것이 효율적일지,
인덱스를 통해 필요한 50만 건만 읽어 오는 것이 효율적일지 판단해야 한다.

인덱스를 이용한 읽기의 손익 분기점이 얼마인지 판단할 필요가 있는데, **일반적인 DBMS의 옵티마이저에서는 인덱스를 통해 레코드 1건을 읽는 것이 테이블에서
직접 레코드 1건을 읽는 것보다 4~5배 정도 더 비용이 많이 드는 작업인 것으로 예측한다.** 즉, 인덱스를 통해 읽어야 할 레코드의 건수(물론 옵티마이저가 판단한
예상 건수)가 전체 테이블 레코드의 20 ~ 25%를 넘어서면 인덱스를 이용하지 말고 직접 테이블을 모두 읽어서 필요한 레코드만 가려내는(필터링) 방식으로 처리하는 것이 효율적이다.

### 다중 칼럼(Multi-column) 인덱스
실제 서비스용 DB에서는 2개 이상의 칼럼을 포함하는 인덱스가 더 많이 사용된다. 2개 이상의 칼럼이 연결됐다고 해서 "Concatenated Index"라고도 한다.

중요한 것은 인덱스의 두 번째 칼럼은 첫 번째 칼럼에 의존해서 정렬 돼 있다는 점이다. 만약 칼럼이 4개인 인덱스를 생성한다면 세 번째 칼럼은 두 번째 칼럼에
의존해서 정렬되고 네 번째 칼럼은 다시 세 번째 칼럼에 의존해서 정렬된다. 다중 칼럼 인덱스에서는 인덱스 내에서 각 칼럼의 위치(순서)가 상당히 중요하며 또한
아주 신중히 결정해야 하는 이유가 바로 여기에 있다.

가끔 인덱스를 구성하는 칼럼 가운데 오름차순(ASC)과 내림차순(DESC)을 혼합해서 만들어야 할 때가 있는데 MySQL에서는 칼럼의 값을 역으로 변환해서
구현하는 것이 유일한 방법이다.
```
CREATE TABLE ranking(
  team_name VARCHAR(20),
  user_name VARCHAR(20),
  user_score INT,
  ...
  INDEX ix_teamname_userscore(team_name, user_score)
);
```
ranking 테이블에서 team_name 칼럼은 오름차순(ASC)으로 정렬하고 user_score는 높은 점수 순서(내림차순)대로 정렬해서 사용자를 조회하려면
어떻게 해야 할까?

```
SELECT team_name, user_name
FROM ranking
ORDER BY team_name ASC, user_score DESC;
```
위와 같이 쿼리를 사용하면 원하는 결과를 조회할 수 있다. 하지만 이 쿼리는 실행의 최종 단계에서 레코드를 정렬하는 과정이 필요하므로 절대로 빠르게 처리할 수 없다.
그래서 이럴 때는 user_score의 값을 역으로 변환해서 저장하는 것이 현재로서는 유일한 방법이다. 즉 user_score 값을 그대로 음수로 만들어서 저장하는 것이다.
그러면 ORDER BY의 정렬 조건을 모두 오름차순(ASC)으로 사용할 수 있게 되므로 별도의 정렬 작업 없이 인덱스를 읽기만 해도 정렬되어 출력되는 것이다.

### B-Tree 인덱스의 가용성과 효율성
쿼리의 WHERE 조건이나 GROUP BY 또는 ORDER BY 절이 어떤 경우에 인덱스를 사용할 수 있고 어떤 방식으로 사용할 수 있는지 식별할 수 있어야 한다.
그래야만 쿼리의 조건을 최적화하거나, 역으로 쿼리에 맞게 인덱스를 최적으로 생성할 수 있다.

**비교 조건의 종류와 효율성**<br>
다중 칼럼 인덱스에서 각 칼럼의 순서와 그 칼럼에 사용된 조건이 동등 비교(=)인지 아니면 크다(>) 또는 작다(<)와 같은 범위 조건인지에 따라 각 인덱스
칼럼의 활용 형태가 달라지며, 그 효율 또한 달라진다.
```
SELECT * FROM dept_emp
WHERE dept_no='d002' AND emp_no >= 10114;
```
case A: dep_no + emp_no<br>
case B: emp_no + dep_no<br>

![](/assets/realmysql_index1.jpeg)


