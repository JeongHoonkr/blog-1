# 열거형(enum)과 어노테이션
###규칙30 : int 상수 대신 enum을 사용하라 
enum자료형에 메서드나 필드를 추가하는 이유는 상수에 데이터를 연계시키면 좋기 때문이다. 
```
public enum Planet {
    MERCURY(3.33, 2.22),
    VENUS(2.22, 3.33),
    MARS(6.66, 7.77),
    URANUS(8.88,9.99);

    private final double mass;
    private final double radius;
    private final double G = 6.67;
    private final double surfaceGravity;

    Planet(double mass, double radius) {
        this.mass = mass;
        this.radius = radius;
        surfaceGravity = G * mass / (radius * radius);
    }

    public double mass() {return mass;}
    public double radius() {return radius;}
    public double surfaceGravity() {return surfaceGravity;}

    public double surfaceWeigt(double mass){
        return mass * surfaceGravity;
    }
```
enum은 원래 변경 불가능하므로 모든 필드는 final로 선언되어야 한다. <br>
enum생성자 안에서는 enum의 static 필드를 접근할 수 없다(컴파일 시점에 상수인 static 필드는 제외). <br>
```
public enum PayrollDay {

    MONDAY(PayType.WEEKDAY),
    TUESDAY(PayType.WEEKDAY),
    WEDNESDAY(PayType.WEEKDAY),
    THURSDAY(PayType.WEEKDAY),
    FRIDAY(PayType.WEEKDAY),
    SATURDAY(PayType.WEEKEND),
    SUNDAY(PayType.WEEKEND);

    private final PayType payType;

    //Constructor
    PayrollDay(PayType payType){
        this.payType = payType;
    }

    double pay(double hoursWorked, double payRate){
        return payType.pay(hoursWorked, payRate);
    }

    // 정책 enum 자료형
    private enum PayType{
        WEEKDAY{
          double overtimePay(double hours, double payRate){
              return hours <= HOURS_PER_SHIFT ? 0 : (hours - HOURS_PER_SHIFT) * payRate / 2;
          }
        },
        WEEKEND{
            double overtimePay(double hours, double payRate){
                return hours * payRate /2;
            }
        };

        private static final int HOURS_PER_SHIFT = 8;

        abstract double overtimePay(double hrs, double payRate);

        double pay(double hoursWorked, double payRate){
            double basePay = hoursWorked * payRate;
            return basePay + overtimePay(hoursWorked,payRate);
        }
    }
}
```

###규칙31 : ordinal 대신 객체 필드를 사용하라 
```
//ordinal을 남용한 사례 
public enum Ensemble{
    SOLO, DUET, TRIO;
    
    public int numberOfMusicians(){
        return ordinal() + 1;
    }
}
```
모든 enum에는 ordinal이라는 메서드가 있는데, enum 자료형 안에서 enum 상수의 위치를 나타내는 정수값을 반환한다. 하지만 객체필드를 사용해라 
```
public enum Ensemble{
    SOLO(1), DUET(2), TRIO(3);
    
    private final int num;
    
    public Ensemble(int size){
        this.num = size;
    }
    
    public int numberOfMusicians(){
        return num; 
    }
}
```
###규칙32 : 비트 필드 대신 EnumSet을 사용하라 
```
//비트 필드 열거형 상수 - 이제는 피해야 할 구현법
public class Text{
    public static final int STYLE_BOLD          = 1 << 0; //1
    public static final int STYLE_ITALIC        = 1 << 1; //2
    public static final int STYLE_UNDERLINE     = 1 << 2 //4
    public static final int STYLE_STRIKETHROUGH = 1 << 3; //8
    
    //이 메서드의 인자는 STYLE_상수를 비트별 OR한 값
    public void applyStyles(int styles) { ... } 
}
```
`text.applyStyles(STYLE_BOLD | STYLE_ITALIC);` 이렇게 하면 상수들을 집합에 넣을 때 비트별 OR 연산을 사용할 수 있다. 하지만 EnumSet 이라는 더 좋은 방법이 있다. 
```
//EnumSet - 비트필드를 대신할 현대적 기술
public class Text{
    public enum Style {
        BOLD, ITALIC, UNDERLINE, STRIKETHROUGH
    }
    
    //어떤 Set 객체도 인자로 전달할 수 있으나, EnumSet이 분명 최선 
    public void applyStyles(Set<Style> styles){ ... }
}
```
`text.applyStyles(EnumSet.of(Style.BOLD, Style.ITALIC));`<br>
EnumSet의 단점이 하나 있는데 변경 불가능 EnumSet객체를 만들 수 없다. 그래서 EnumSet 객체를 Collections.unmodifiableSet으로 포장하면 되는데, 성능이나 코드 가독성 측면에서 좀 손해를 보게 된다. 

###규칙33 : ordinal을 배열 첨자로 사용하는 대신 EnumMap을 이용하라 

```
class Herb{
	enum Type { ANNUAL, PERENNIAL, BIENNIAL }

	final String name;
	final Type type;

	Herb(String name, Type type){
		this.name = name;
		this.type = type;
	}

	@Override
	public String toString(){
		return name; 
	}
}
```
```
//EnumMap을 사용해  enum 상수별 데이터를 저장하는 프로그램
Herb[] garden = …; 

Map<Herb.Type, Set<Herb>> herbsByType =
	new EnumMap<Herb.Type, Set<Herb>>(Herb.Type.class);

for(Herb.Type t : Herb.Type.values())
	herbsByType.put(t, new HashSet<Herb>());

for(Herb h : garden)
	herbsByType.get(h.type).add(h);

System.out.println(herbsByType);
```
EnumMap 생성자가 키의 자료형을 나타내는 Class 객체를 인자로 받는다는 것에 주의하자. 이런 Class 객체를 한정적 자료형 토큰이라고 부르는데, 실행시점 제네릭 자료형 정보를 제공한다. <br>

두 번째 예제는 상전이(phase transition) 관계를 표현하기 위해서 중첩 EnumMap을 사용했다. 
```
// EnumMap을 중첩해서 enum 쌍에 대응되는 데이터를 저장한다
public enum Phase{
	SOLID, LIQUID, GAS;

	public enum Transition{
		MELT(SOLID, LIQUID), FREEZE(LIQUID, SOLID),
		BOIL(LIQUID, GAS), CONDENSE(GAS, LIQUID),
		SUBLIME(SOLID, GAS), DEPOSIT(GAS, SOLID);

		private final Phase src;
		private final Phase dat;

		Transition(Phase src, Phase dst){
			this.src = src;
			this.dst = dat;
		}

		//상 전이 맵 초기화 
		private static final Map<Phase, Map<Phase, Transition>> m =
			new EnumMap<Phase, Map<Phase, Transition>>(Phase.class);
		static{
			for(Phase p : Phase.values())
				m.put(p, new EnumMap<Phase, Transition>(Phase.class));

			for(Transition trans : Transition.values())
				m.get(trans.src).put(trans.dst, trans);
		}

		public static Transition from(Phase src, Phase dat) {
			return m.get(src).get(dst);
		}
	}
}
```
![](EnumMapexample.jpg)

LIQUID쪽을 보면 액체 LIQUID에서 고체 SOLID로 변하는 것은 언다FREEZE라고 한다. 이 맵의 자료형은 `Map<Phase, Map<Phase, Transition>>`인데, “상전이 이전 상태를, 상전이 이후 상태와 상전이 명칭 사이의 관계를 나타내는 맵에 대응시키는 맵”이라는 뜻이다. 

