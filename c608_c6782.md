# 예외
###규칙57 : 예외는 예외적 상황에만 사용하라 
```
// 예외를 끔찍하게 남용한 사례. 이러면 곤란하다.
try {
	int i = 0;
	while(true)
		range[i++].climb();
}catch(ArrayIndexOutOfBoundsException e){ }
```
무슨일을 하는 코드인지 전혀 명확하지 않다. 이 코드에 포함된 무한 루프는 배열 범위 밖에 있는 첫 번째 요소를 참조하는 순간에 발생하는 ArrayIndexOutOfBoundsException예뢰를 감지하고 무시하는 과정을 통해 종료된다. **예외는 예외적인 상황에만 사용해야지, 평상시 제어 흐름에 이용해서는 안된다.** <br>

잘 설계된 API는 클라이언트에게 평상시 제어 흐름의 일부로 예외를 사용하도록 강요해서는 안 된다. 특정한 예측 불가능 조건이 만족될 때만 호출할 수 있는 “상태 종속적” 메서드를 가진 클래스에는 보통 해당 메서드를 호출해도 되는지를 알기 위한 “상태 검사” 메서드가 별도로 갖춰져 있다. 예를 들어 Iterator 인터페이스에는 상태 종속적 메서드 next가 있고, 상태 검사 메서드 hasNext가 있다. Iterator에 hasNext 메서드가 없었다면 클라이언트는 어쩔 수 없이 아래와 같은 코드를 만들어야 했을 것이다.
```
// 이렇게 하면 곤란
try {
	Iterator<Foo> i = collection.iterator();
	while(true) {
		Foo foo = i.next();
	}
}catch (NoSuchElementException e) { }
```
상태 검사 메서드를 제공하기 싫다면, 부적절한 상태의 객체에 상태 종속적 메서드를 호출하면 null 같은 특이값이 반환되도록 구현하는 방법도 있다. 그러나 이 기법은 Iterator에는 사용할 수 없는데, null은 next 메서드의 정상적 반환값 가운데 하나이기 때문이다. **외부적인 동기화 메커니즘 없이 병렬적으로 사용될 수 있는 객체거나, 외부적인 요인으로 상태 변화가 일어날 수 있는 객체라면 반드시 특이값 방식으로 구현해야 한다. 상태 검사 메서드를 호출한 다음 상태 종속적 메서드를 호출하기까지의 시간 동안 객체 상태가 변할 수 있기 때문이다.**
###규칙58 : 복구 가능 상태에는 점검지정 예외를 사용하고, 프로그래밍 오류에는 실행시점 예외를 이용하라
