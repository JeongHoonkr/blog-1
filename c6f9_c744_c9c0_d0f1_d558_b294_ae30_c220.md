# 웹을 지탱하는 기술

HTTP는 원래 하이퍼텍스트를 전송하기 위한 프로토콜이었지만, 실제로는 하이퍼텍스트 이외의 다양한 것들을 전송하고 있다. 그것이 무엇인가 하면, 리소스 상태(Resource State)의 표현(Representation)이라는 것이 필딩의 주장이다(REST 창시자). <br>

**리소스**<br>
REST에 있어서 중요한 개념의 하나로 리소스가 있다. 우선 웹에서 리소스의 예를 보자.<br>
```
서울의 일기예보
청량리역의 사진
다음 웹 페이지
Dijkstra의 논문 'Go To Statement Considered Harmful'
```
웹 상에서는 이 밖에도 다양한 리소스가 존재한다. 리소스를 한마디로 설명하면, '웹상에 존재하는 이름을 가진 모든 정보'가 된다. <br>

**리소스 명칭으로서의 URI**<br>
```
서울의 일기 예보
http://weather.daum.net/rgn/cityWetrWarea  

청량리역의 사진
http://wwwflickr.com/photos/nala2sky/2121321/ 

Dijkstra의 논문 'Go To Statement Considered Harmful'
http://www.ecn.purdue.edu/ParaMount/papers/diijkstra68goto.pdf

cf) 복합한 URI의 예
http://yohei:pass@blog.example.com:8000/search?q=test&debug=true#n10
URI 스키마(hhtp) 다음에 사용자 정보가 들어가 있다. 사용자 정보는 이 리소스에 접근할 때 이용할 사용자 이름과 패스워드로 구성된다. 
```
즉, 리소스란 웹상의 정보이다. 전 세계 무수한 리소스는 각각 URI로 의미 있는 이름을 가진다. URI를 이용함으로써, 프로그램은 리소스가 표현하는 정보에 접근할 수 있다. <br>

**클라이언트/서버**<br>
웹은 HTTP라는 프로토콜을 이용해 클라이언트와 서버가 서로 통신하는 클라이언트/서버의 아키텍처 스타일을 채용하고 있다. 클라이언트/서버의 이점은 단일 컴퓨터 상에서 모든 것을 처리하는 것이 아니라, 클라이언트와 서버로 분리해서 처리할 수 있다는 점이다. <br>

**URI, URL, URN**<br>
URI와 비슷한 이름으로 URL과 URN이 있다. 정확히 말하지면 URI는 URL과 URN을 총칭하는 이름이다. URL에는 도메인을 갱신하지 않았거나 서버가 어떤 장애로 인해 변경되면 액세스 할 수 없다는 문제가 있다. 이 문제에 대응하기 위해 도메인명과는 독립적으로 리소스에 항구적인 ID를 할당하기 위한 스펙이 검토되었고 그 결과가 URN이다. URN을 이용하면 리소스에 도메인명과는 독립된 이름을 붙일 수 있다. 예를 들어 서적은 ISBN이라는 세계적으로 통일된 ID를 갖고 있다. `urn:isbn:924483858493` 이렇게 URN은 도메인명에 의존하지 않는다. 이런 특성을 가진 URL과 URN을 합해 URI라고 부르게 되었다. 즉, URI는 2개의 ID체계를 합한 총칭이다. <br>

##HTTP의 기본
HTTP란 이름대로라면 하이퍼텍스트 전송용 프로토콜이지만, 실제로는 HTML과 XML 같은 하이퍼텍스트뿐만 아니라 이미지, 음성, 동영상, JavaScript 프로그램, PDF와 각종 오피스 도큐먼트 파일 등 컴퓨터에서 다룰 수 있는 데이터라면 무엇이든 전송할 수 있다.<br>

##HTTP 메서드
##스테이터스 코드
##HTTP 헤더

##JSON
JavaSript Object Notation의 약자로 **데이터 표현 형식 중 하나**이다. <br>

JSON의 미디어 타입은 `application/json`이다. JSON은 스펙 상 UTF-8, UTF-16, UTF-32 중 하나로 인코딩하도록 되어 있다. 따라서 HTTP 헤더 등의 미디어 타입에서 파라미터로 지정할 수 있다. 
```
Content-Type: application/json; charset=utf-8
```
cf) front에서 AJAX 통신할 때
```
$.ajax({
          type: 'get',
          url: '/message/random',
          contentType: 'application/json',
          dataType: 'json',
          success: function (data) {
          },
          error: function(data){
          }
      });
```
contentType 을 통해서 json형식이라는 것을 알리고 response로 받아오는 데이터도 json이라는 것을 dataType을 통해 명시한다. <br>

JSON 자료형은 object, array, string, number, boolean, null 이렇게 총 6가지가 있다. JSON의 문자열은 반드시 이중인용부호(")로 감싸준다. <br>

**JSON에 의한 크로스 도메인 통신**<br>
JSON으로 리소스 표현을 제공하는 부차적 효과로서, JSONP(JSON with PAdding)을 이용할 수 있다. JSONP가 필요하게 된 배경부터 설명하면, Ajax에서 이용하는 XMLHttpRequest라는 JavaScript의 모듈은 보안상의 제한으로 인해 JavaScript 파일을 가져왔던 동일한 서버하고만 통신할 수 있다. JavaScript가 있는 서버와 다른 서버가 통신할 수 있다면 브라우저에서 입력한 정보를 사용자가 모르는 사이에 부정한 서버로 전송할 수 있게 되기 때문이다.<br>

이와 관련해, 이렇게 불특정 다수의 도메인에 속하는 서버에 액세스하는 것을 '크로스 도메인 통신'이라고 부른다. 복수 도메인의 서버와 통신할 수 없고 단일 도메인과만 통신해야 한다는 것은 커다란 제약이다. 예를 들어, 우리 서비스에서 데이터를 직접 들고 있지 않고 다른 웹 API를 통해 받아올 수 없기 때문이다.<br>

XMLHttpRequest에서는 크로스 도메인 통신을 할 수 없지만 대체 수단이 있다. 
```
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <script src="http://example.jp/map.js"></script> 
    <script src="http://example.jp/zip.js"></script>
    ...
  </head>
</html>
```
HTML의 script 요소를 이용하면 복수의 사이트에서 JavaScript 파일을 읽을 수 있다. script 요소는 역사적인 이유에서 일반적으로 브라우저의 보안제한을 받지 않는다.<br>

JSONP는 브라우저의 이런 성질을 이용해 크로스 도메인 통신을 구현하는 방법이다. JSONP에서는 오리지널 JSON을 클라이언트가 지정한 콜백 함수명으로 랩핑하여 도메인이 다른 서버로부터 데이터를 취득한다. 
```
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
     <title>크로스 도메인 통신의 예</title>
  </head>
  <body>
    <script type="text/javascript">
      function foo(zip){
        alert(zip["zipcode"]);
      }
    </script>
    <script src="http://zip.ricollab.jp/1120002.json?callback=foo"></script>
  </body>
</html>
```
브라우저에서 이 html파일을 렌더링하면 두번째 script 요소인 JSONP의 URI를 자동적으로 GET하여 다음 통신이 수행된다.
```
요청
GET /1120002.json?callback=foo HTTP/1.1
Host: zip.ricollab.jp
```
```
응답
HTTP/1.1 200 OK
Content-Type: application/javascript

foo({
  "zipcode": "1120002",
  "address": {
    "prefecture": "도쿄도",
    "city": "분쿄구",
    "town": "코이시카와"
    },
  "yomi":{
    "prefecture": "토우쿄우토",
    "city": "분쿄우쿠",
    "town": "코이시카와"
    }
  });
```
요청한 URI에는 callback이라는 쿼리 파라미터에서 콜 백 함수로 foo를 지정하고 있기 때문에 응답의 바디에는 foo 함수를 호출하는 JavaScript의 코드가 들어 있다. foo 함수의 인수로는 요청 URI에서 지정한 우편번호인  1120002가 JSON으로 들어 있다. 이에 따라 첫 번째 script 요소에서 정의한 foo 함수를 1120002라는 우편번호 정보를 인수로 하여 호출하고, 결과로 브라우저가 1120002라는 알림창을 표시한다.<br>

foo함수를 정의한 HTML 파일은 우편번호 정보를 zip.ricollab.jp에서 가져오고 있다는 점을 주목하자. 이것이 JSONP로 크로스 도메인 통신을 구현하는 방법이다. 이 예에서는 콜백 함수를 지정한 script 요소를 HTML에 직접 삽입하고 있지만, 보통은 사용자의 입력에 대응해 JavaScript로 HTML을 조적해서 동적으로 삽입한다.

리다이렉션 / 포워딩 
세션 / 쿠키 / 서블릿
