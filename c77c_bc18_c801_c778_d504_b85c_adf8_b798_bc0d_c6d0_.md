# 일반적인 프로그래밍 원칙들
###규칙45 : 지역 변수의 유효범위를 최소화하라
C와 같은 오래된 프로그래밍 언어는 지역 변수를 블록 앞부분에 선언한다. 그러나 고칠 필요가 있는 습관이다. **지역 변수의 유효범위를 최소화하는 가장 강력한 기법은, 처음으로 사용하는 곳에서 선언하는 것이다.** 사용하기 전에 선언하면 프로그램의 의도를 알고자 소스 코드를 읽는 사람만 혼란스럽게 할 뿐이다. 실제로 변수가 사용될 때쯤 되면, 그 변수의 자료형과 초기값이 무엇이었는지는 잊어버리고 말 것이다. <br>

지역 변수를 너무 빨리 선언하면 유효범위가 너무 앞쪽으로 확장될 뿐 아니라, 너무 뒤쪽으로도 확장된다. **지역 변수의 유효범위는 선언된 지점부터 해당 블록 끝까지다.** 어떤 블록 밖에서 선언된 변수는 프로그램이 해당 블록 수행을 끝내고 나서도 계속 사용 가능하다. 어떤 변수를 원래 사용하려고 했던 곳 이외의 장소에서 실수로 사용하게 되면, 끔찍한 결과가 초래될 수 있다. <br>

**거의 모든 지역 변수 선언에는 초기값이 포함되어야 한다.** 그런데 try-catch 블록이 사용 될 때는 예외적 상황이 생길 수 도 있다. 어떤 변수가 점검지정 예외(checked exception)을 던지는 메서드를 통해 초기화된다면 그 변수는 try 블록 안에서 초기되어야 할 것이다. 그런데 그 변수의 값이 try 블록 밖에서도 사용할 수 있어야 하는 값이라면 선언 위치를 try 블록 앞으로 이동시켜야 한다. <br>

순환문(loop)을 잘 쓰면 변수의 유효범위를 최소화할 수 있다. for문이나 for-each문의 경우, 순환문 변수라는 것을 선언할 수 있는데, 그 유효범위는 선언된 지역(즉, for 다음에 오는 순환문 괄호 ()와 순환문 몸체 {} 내부의 코드) 안으로 제한된다. 따라서 **while 문보다는 for 문을 쓰는 것이 좋다.** 순환문 변수의 내용은 순환문 수행이 끝난 이후에는 필요 없다는 가정하에서. 예를 들어, 컬렉션을 순회할 때는 아래와 같이 하는 것이 좋다.
```
// 컬렉션을 순회할 때는 이 숙어대로 하는 것이 바람직
for (Element e : c) {
	doSomething(e);
}
```
이런 for 순환문이 while 문보다 바람직한 이유는 무엇인가? 아래의 코드를 보자. while 문이 두 개 사용되었고, 버그도 하나 있다. 
```
Iterator<Element> i = c.iterator();
while(i.hasNext()){
	doSomething(i.next());
}
…
Iterator<Element> i2 = c2.iterator();
while(i.hasNext()){ // 버그 
	doSomething(i2.next());
}
```
두 번째 순환문에는 코드를 복붙하다보니 생긴 버그가 하나 있다. 새로운 순환문 변수 i2를 초기화 했으나 실제로는 옛날 변수 i를 써버린 것이다. i가 아직도 유효범위 안에 있는 관계로, 이 코드는 컴파일이 잘 될뿐 아니라 예외도 없이 실행되지만 이상하게 동작할 것이다. 이와 비슷한 복붙 버그가 for 문이나 for-each 문에서도 생길 수 있을까? 컴파일조차 되지 않을 것이므로 어려울 것이다. 첫 번째 순환문 안에서 사용된 요소나 반복자의 유효범위는 두 번째 순환문까지 연장될 수 없다. 아래의 예제를 보자.
```
for(Iterator<Element> i = c.iterator(); i.hasNext();){
	doSomething(i.next());
}
…
//심볼 i를 찾을 수 없다면서 컴파일 시점에 오류 발생
for(Iterator<Element> i2 = c2.iterator(); i.hasNext();){
	doSomething(i2.next());
}
```
더욱이 for문을 사용할 때는 순환문마다 다른 이름으 변수를 사용할 필요가 없기 때문에 복붙 버그가 발생할 가능성은 더욱 줄어든다. 각각의 for 문은 서로 의존성이 없으므로, 같은 변수명을 거듭 사용해도 상관없다. 지역 변수의 유효범위를 최소화하는 숙어를 하나 더 살펴보자.
```
for (int i = 0 , n = expensiveComputation(); i< n ; i++){
	doSomething(i);
}
```
여기서 주의할 것은 두 개의 순환문 변수가 사용되었다는 것이다. i와 n의 유효범위는 정확히 해당 for문 안으로 제한된다. 두번째 변수 n은 i값의 범위를 제한하는 용도로 쓰이고 있는데, 그 값을 계산하는 비용이 꽤 크다. 따라서 미리 계산해 넣어두고 사용함으로써 매번 재계산할 필요가 없도록 했다. **명심할 것은, 순환문 조건식 안에서 메서드를 호출할 경우, 해당 메서드의 호출 결과로 반환되는 값이 순환문 각 단계마다 달라지지 않는다면, 항상 이 패턴대로 코딩하라는 것이다. **<br>

지역 변수의 유효범위를 최소화하는 마지막 전략은 **메서드의 크기를 줄이고 특정한 기능에 집중하라는 것이다.** 두 가지 서로 다른 기능을 한 메서드 안에 넣어두면 한 가지 기능을 수행하는 데 필요한 지역 변수의 유효범위가 다른 기능까지 확장되는 문제가 생긴다. 이런 일을 막으려면 각 기능을 나눠서 별도 메서드로 구현해야 한다. 

###규칙46 : for 문보다는 for-each 문을 사용하라
릴리스 1.5 전에는 컬렉션을 순회할 때 아래으 숙어를 따르는 것이 바람직했다.
```
// 컬렉션 순회를 위해 한동안 많이 썼던 숙어
for (Iterator i = c.iterator(); i.hasNext(); ){
	doSomething((Element) i.next()); // 1.5 전에는 제네릭 없었음
}
```
배열을 순회할 때는 이렇게 하는 것이 바람직 했다.
```
// 배열 순회할 때 한동안 많이 사용한 숙어
for (int i =0; i< a.length; i++){
	doSomething(a[i]);
}
```
릴리스 1.5부터 도입된 for-each 문은 성가신 코드와 반복자, 첨자 변수들을 완전히 제거해서 오류 가능성을 없앤다.
```
// 컬렉션이나 배열을 순회할 때는 이 숙어를 따르자
for (Element e : elements){
	doSomething(e);
}
```
위의 for-each 문에서 `:` "기호는 안에 있는(in)”이라고 읽는다. 따라서 위의 순환문은 “elements 안에 있는 e 각각에 대해서(for)” 라고 읽으면 된다. for-each 문의 장점은 여러 컬렉션에 중첩되는 순환문을 만들어야 할 때 더 빛난다. 두 개 컬렉션에 대한 순환문을 중첩시킬 때 흔히 저지르는 실수의 사례를 아래에 보였다.
```
// 버그 있는 코드
enum Suit { CLUB, DIAMOND, HEART, SPADE }
enum Rank { ACE, DEUCE, THREE, FOUR, FIVE, SIX, SEVEN, EIGHT, NINE, TEN, JACK, QUEEN, KING }
…
Collection<Suit> suits = Arrays.asList(Suit.values());
Collection<Rank> ranks = Arrays.asList(Rank.values());

List<Card> deck = new ArrayList<Card>();
for ( Iterator<Suit> i = suits.iterator(); i.hasNext(); )
	for ( Iterator<Rank> j = rank.iterator(); j.hasNext(); )
		deck.add(new Card(i.next(), j.next())); 
```