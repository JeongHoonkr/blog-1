# 자료구조&알고리즘

사향이진트리 시간복잡도는 O(n), 완전 이진트리 시간복잡도는 O(log2(n))<br><br>
B-tree 시간복잡도는 O(log2(n)), 그러나 삽입/삭제 연산에 있어 노드 상에서 모든 정보를 수정하기 위해 O(m)의 작업이 요구된다. 최악의 경우, 삽입/삭제 연산에 있어 수행시간은 O(m * logm(n))이 걸린다. 그러나 단순 검색 연산은 O(logn)이 걸린다. <br><br>
셸 정렬은 매개변수에 의해 몇 개의 서브파일로 나누어 서브파일 별로 삽입정렬을 하고 최후에 하나의 파일로 결합하여 삽입정렬하는 방식 실행시간은 O(n(logn)^2) 또는 O(n^2)으로써 단순 삽입정렬보다는 효율이 좋다. 
<br><br>
힙 정렬은 O(n(logn)) 트리구조를 구성하는데 시간이 소모되므로 퀵 정렬 보다 시간이 통계적으로 두배정도 걸린다. 하지만 항상 동일한 성능 보장한다.

###1부터 100까지 소수구하기 - 에라토스테네스의 체
2부터 시작해서 2의 배수는 모두 걸러낸다. 다음 3의 배수 모두 걸러낸다. 다음 4는 이미 걸러졌고 5의 배수를 모두 걸러낸다 ... (반복) 
```
int main(){
    int i;
    int start, check; 
    int arr[120]; 
    
    //초기화
    for(i=2;i<=100;i++){
        arr[i]=i;
    }
    
    //에라토스테네스의 체 알고리즘 
    for(start =2; start * start <= 100; start++){
        
        if(arr[start] == 0) continue; 
        
        for(check = start * start; check <= 100; check+=start){
            arr[check] = 0;
        }
    }
    
    for(i=2;i<=100;i++){
        if(arr[i])
            printf("%d\n",i);
    }
}
```