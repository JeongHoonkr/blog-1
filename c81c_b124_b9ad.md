# 제네릭
###규칙23 : 새 코드에는 무인자 제네릭 자료형을 사용하지 마라
`List<String>`는 원소 자료형이 String인 리스트를 나타내는 형인자 자료형이다.

각 제네릭 자료형은 새로운 무인자 자료형을 정의하는데, 무인자 자료형은 실 형인자 없이 사용되는 제네릭 자료형이다. ex) `List list = new ArrayList<>();` 무인자 자료형 List는 제네릭 도입 이전의 인터페이스 자료형 List와 똑같이 동작한다. 하지만 **제네릭 자료형을 형인자 없이 사용하면 안된다.** 무인자 자료형을 쓰면 형 안전성이 사라지고, 제네릭의 장점 중 하나인 표현력 측면에서 손해를 보게 된다.

제네릭 자료형을 쓰고 싶으나 실제 형 인자가 무엇인지는 모르거나 신경 쓰고 싶지 않을 때는 형 인자로 '?'를 쓰면 된다. 하지만 null 이외의 어떤 원소도 넣을 수 없기 때문에 한정적 와일드 카드 자료형을 쓰면 된다. ex) `<T extends Number>`

새로 만든 코드에는 무인자 자료형을 쓰면 안된다고 했지만, 그 규칙에도 사소한 예외가 두 가지 있다. 제네릭 자료형 정보가 프로그램이 실행될 때는 지워지기 때문에 생긴 예외들이다. 첫 번째는 클래스 리터럴에는 반드시 무인자 자료형을 사용해야 한다. 자바 표준에 따르면, 클래스 리터럴에는 형인자 자료형을 쓸 수 없다.(배열 자료형이나 기본 자료형은 가능) 예를 들어, `List.class, String[].class, int.class`는 가능하지만 `List<String>.class나 List<?>.class`는 사용할 수 없다는 뜻이다. 두 번째는 제네릭 자료형에 instanceof 연산자를 적용할 때는 다음과 같이 하는 것이 좋다.
```
//instanceof 연산자에는 무인자 자료형을 써도 OK
if(o instanceof Set){ //무인자 자료형
    Set<?> m = (Set<?>) o; //와일드카드 자료형 
}
```

###규칙24 : 무점검(unchecked warning) 경고를 제거하라
제거할 수 없는 경고 메세지는 형 안전성이 확실할 때만 `@SupressWarnings("unchecked")`애노테이션을 사용해 억제해라. 개별 지역 변수 선언부터 클래스 전체에까지, 어떤 크기의 단위에도 적용할 수 있지만 가능한 한 작은 범위에 적용해라. 보통은 변수 선언이나 아주 짧은 메서드 또는 생성자에 붙인다. **절대로 클래스 전체에 SupressWarnings을 적용하지 마라.** 그리고 이 애노테이션을 사용할 때마다, 왜 형 안전성을 위반하지 않는지 밝히는 주석을 반드시 붙여라.

무점검 경고를 무시하면 프로그램 실행 도중에 CalssCastException이 발생할 가능성이 있다. 

###규칙25 : 배열 대신 리스트를 써라
배열은 공변 자료형이다. 
