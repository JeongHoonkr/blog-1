# 직렬화
###규칙74 : Serializable 인터페이스를 구현할 때는 신중하라
클래스 선언부에 "implements Serializable"만 붙이면 직렬화 가능한 객체를 만드는 클래스를 구현할 수 있을 때도 있다. 너무 간단하기 때문에, 직렬화를 지원하기 위해 프로그래머 입장에서 해야 하는 일이 별로 없다는 잘못된 믿음이 만연해 있지만 사실은 훨씬 더 복잡하다. <br>

**Serializable 구현과 관련된 가장 큰 문제는 일단 클래스를 릴리스하고 나면 클래스 구현을 유연하게 바꾸기 어려워진다.** Serializable을 구현하면, 그 클래스의 바이트 스트림 인코딩도 공개 API의 일부가 되어 버린다. 따라서 아무리 잘 설계한 직렬화 형식도 클래스 진화라는 관점에서 보면 족쇄가 될 수 있다.<br>

**두 번째 문제는 버그나 보안 취약점이 발생할 가능성이 높아진다.** 보통 객체는 생성자를 통해 생성한다. 직렬화는 언어 외적인 객체 생성 메커니즘이다. 기본 동작을 받아들이건 재정의 하건 간에, 역직렬화는 생성자와 동일한 이슈를 갖고 있는 "숨은 생성자"다. 역직렬화 과정에 관계된 생성자가 명시적으로 존재하지 않기 때문에 불변식 훼손이나 불법 접근 문제에 쉽게 노출된다. <br>

**세 번째 문제는 새 버전 클래스를 내놓기 위한 테스트 부담이 늘어난다는 것이다.** 직렬화 가능 클래스를 수정할 때는, 새 릴리스에서 만들고 직렬화한 객체를 예전 릴리스에서 역직렬화할 수 있는지, 그리고 그 역도 가능한지 검사하는 것이 중요하다. <br>

**상속을 염두에 두고 설계하는 클래스는 Serializable을 구현하지 않는 것이 바람직하다. 또한 인터페이스는 가급적 Serializable을 상속하지 말아야 한다.** 하지만 예를 들어 Serializable을 구현하는 객체만 참여가 가능한 프레임워크가 있을 때, 이런 프레임워크를 이용하려면 클래스나 인터페이스가 Serializable을 구현하거나 계승하도록 해야 할 것이다.<br>

객체 필드를 갖는 클래스를 직렬화 가능하고 계승 가능한 클래스로 구현할 때는 반드시 조심해야 할 것이 하나 있다. 객체 필드가 기본값으로 초기화되면 위배되는 불변식이 있는 경우에는 아래의 readObjectNoData 메서드를 클래스에 반드시 추가해야 한다.
```
// 상태유지 계승 가능 직렬화 가능
// 클래스에 대한 readObjectNoData 메서드 
private void readObjectNoData() throws InvalidObjectException {
  throw new InvalidObjectException("Stream data requied");
}
```
