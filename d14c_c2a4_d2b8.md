# 테스트

JUnit 프레임워크가 요구하는 조건 두가지, 첫째는 메서드가 public으로 선언되어야 하고 두번째는 @Test 애노테이션 붙여줘야한다.(하나의 클래스에 안에 여러 개의 테스트 메서드가 들어가는 것도 허용하는데 리턴 값이 void형이고 파라미터가 없다는 조건을 지키면 된다.)

테스트의 결과를 검증하는 if/else대신 JUnit이 제공하는 assertThat을 사용한다. 

cf) 인텔리제이 IDE에서 assertThat import 자동으로 안해준다. 
```
import static org.hamcrest.CoreMatchers.is; 
import static org.junit.Assert.assertThat; 

assertThat(user2.getName(), is(user.getName()));
```

JUnit은 특정한 테스트 메서드의 실행 순서를 보장해주지 않는다. 데스트의 결과가 테스트 실행 순서에 영향을 받는다면 테스트를 잘못 만든 것이다. 

**모든 테스트는 실행 순서와 상관없이 독립적으로 항상 동일한 결과를 낼 수 있도록 해야 한다. **<br>

예외가 반드시 발생해야 하는 경우를 테스트하고 싶을 때는 @Test 애노테이션의 expected 엘리먼트를 사용하면 된다. expected는 테스트 메서드 실행 중에 발생하리라 기대하는 예외 클래스를 넣어주면 된다. 
```
@Test(expected=EmptyResultDataAccessException.class)
public void getUserFailure() throws SQLException{
    ...
    
    dao.get("unknown_id");
}
```

`@Before @After`테스트 코드들의 공통적인 작업을 처리하는 애노테이션

픽스처(fixture) : 테스트를 수행하는 데 필요한 정보나 오브젝트
```
public class UserDaoTest{
    private UserDao dao;
    private User user1;
    private User user2;
    private User user3;
    
    @Before
    public void setUp(){
        ...
        this.user1 = new User("gyumee", "박성철", "springno1");
        this.user2 = new User("leegw700", "이길원", "springno2");
        this.user3 = new User("bumjin", "박범진", "springno3");
    }
    ...
}
```