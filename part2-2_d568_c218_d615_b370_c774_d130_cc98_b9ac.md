# Part2-2 함수형 데이터 처리
##6장 - 스트림으로 데이터 수집
4장과 5장에서는 스트림에서 최종 연산 collect를 사용하는 방법을 확인했다. 하지만 toList로 스트림 요소를 항상 리스트로만 변환했다. 이 장에서는 reduce가 그랬던  것처럼 collect 역시 다양한 요소 누적 방식을 인수로 받아서 스트림을 최종 결과로 도출하는 리듀싱 연산을 수행할 수 있음을 설명한다.
```
// 통화별로 트랜잭션을 그룹화한 코드 - 명령형 버전
Map<Currency, List<Transaction>> transactionByCurrencies = new HashMap<>();

for(Transaction transaction : transactions){
  Currency currency = transaction.getCurrency();
  List<Transaction> transactionForCurrency = transactionByCurrencies.get(currency);
  
  if(transactionForCurrency == null){
    transactionForCurrency = new ArrayList<>();
    transactionByCurrencies.put(currency, transactionForCurrency);
  }
  
  transactionForCurrency.add(transaction);
}
```
통화별로 트랜잭션 리스트를 그룹화하기 위해 위와 같은 방법도 있지만 자바8에서는 더 간결한 구현이 가능하다.
```
Map<Currency, List<Transaction>> transactionByCurrencies = 
  transactions.stream().collect(groupingBy(Transaction::getCurrency));
```
###컬렉터란 무엇인가?
Collector 인터페이스 구현은 스트림의 요소를 어떤 식으로 도출할지 지정한다. 5장에서는 '각 요소를 리스트로 만들어라'를 의미하는 toList를 Collector 인터페이스의 구현으로 사용했다. 여기서는 groupingBy를 이용해서 '각 키(통화) 버킷 그리고 각 키 버킷에 대응하는 요소 리스트를 값으로 포함하는 맵을 만들라'는 동작을 수행한다.<br>

cf) collect 메서드로 Collector 인터페이스 구현을 전달한다. 스트림에 collect를 호출하면 스트림의 요소에 내부적으로 리듀싱 연산이 수행된다. <br>

**리듀싱과 요약**<br>
첫 번째 예제로 counting()이라는 팩토리 메서드가 반환하는 컬렉터로 메뉴에서 요리 수를 계산한다.<br>
`long howMayDishes = menu.stream().collect(counting());` <br>

두 번째는 메뉴에서 칼로리가 가장 높은 요리를 찾는다고 해보자. Collectors.maxBy, Collectors.minBy 두 개의 메서드를 이용해서 스트림의 최댓값과 최솟값을 계산할 수 있다. 두 컬렉터는 스트림의 요소를 비교하는데 사용할 Comparator를 인수로 받는다.
```
Comparator<Dish> dishCaloriesComparator = Comparator.comparingInt(Dish::getCalories);

Optional<Dish> mostCalorieDish = menu.stream().collect(maxBy(dishCaloriesComparator));
```
또한 스트림에 있는 객체의 숫자 필드의 합계나 평균 등을 반환하는 연산에도 리듀싱 기능이 자주 사용된다. 이러한 연산을 **요약 연산**이라 부른다.<br>

다음은 메뉴 리스트의 총 칼로리를 계산하는 코드다. `int totalCalories = menu.stream.collect(summingInt(Dish::getCalories));` summingInt 뿐만 아니라 summingLong, summingDouble, averagingInt, averagingLong, averagingDouble 등 다양한 형식이 존재한다.
```
// 요소수, 칼로리합계, 평균, 최대/최소값 
IntSummaryStatistics menuStatistics = menu.stream().collect(summarizingInt(Dish::getCalories));
```
위 코드를 실행하면 IntSummaryStatistics 클래스로 모든 정보가 수집된다.
```
IntSummaryStatistics { count=9, sum=4300, min=120, average=477.777778, max=800 }
```
마찬가지로 int뿐 아니라 long이나 double에 대응하는 summarizingLong, summarizingDouble 메서드와 관련된 LongSummaryStatistics, DoubleSummaryStatistics 클래스도 있다. <br>

**문자열 연결**<br>
문자열 연결을 위해 joining메서드는 내부적으로 StringBuilder를 이용해서 문자열을 하나로 만든다. 추가적으로 연결된 문자열들 사이에 구분 문자열을 넣을 수 있도록 오버로드된 joining 팩토리 메서드도 있다.
`String shortMenu = menu.stream().map(Dish::getName).collect(joining(","));`<br>

**범용 리듀싱 요약 연산**<br>
지금까지 살펴본 모든 컬렉터는 reducing 팩토리 메서드로도 정의할 수 있다. 즉 범용 Collectors.reducing으로도 구현할 수 있다. 
```
int totalCalories = menu.stream().collect(reducing(0, Dish::getCalories, (i,j) -> i+j));
```
reducing은 세 개의 인수를 받는다. 첫 번째 인수는 리듀싱 연산의 시작값이거나 스트림에 인수가 없을 때는 반환값이다. 두 번째 인수는 변환 함수다. 세 번째 인수는 같은 종류의 두 항목을 하나의 값으로 더하는 BinaryOperator다. <br>

다음처럼 한 개의 인수를 가진 reducing 버전을 이용해서 가장 칼로리가 높은 요리를 찾는 방법도 있다.
```
Optional<Dish> mostCalorieDish = menu.stream().collect(reducing(
  (d1, d2) -> d1.getCaloriees() > d2.getCalories() ? d1 : d2));
```
한 개의 인수를 갖는 reducing 컬렉터는 시작값이 없으므로 빈 스트림이 넘겨졌을 때 시작값이 설정되지 않는 상황이 벌어진다. 그래서 Optional로 받고, 반환함수가 자기 자신이기 때문에(항등 함수) 최종적으로 `Optional<Dish>` 객체를 반환한다.<br>


