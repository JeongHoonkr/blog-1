**1. TraceId 작동 사례**<br> 
하나의 Trace는 Span들의 집합이고 각각의 Span은 RPC가 도착할 때 처리할 작업을 나타내며 추적에 필요한 데이터를 가지고 있다. 그 데이터는 TraceId인데 TraceId는 TransactionId와 SpanId, ParentId로 이루어진 키의 집합이다. 

이 TraceId를 HTTP 헤더에 넣어서 전송함으로써 각각의 노드 간의 관계를 정의 할 수 있다. 결국 Trace는 사용자의 한 요청에 따라 동작되는 모든 로직을 의미한다. 그래서 한 Trace에 TransactionId가 같게 하는 것이다. 

PRC 호출을 위한 기반조건은, RPC 호출시 TraceId를 넣을 공간이 있다면 하면 어떤 형태의 RPC도 추적할수 있다. Thrift같은 경우는 헤더 공간이 없어서, 강제로 -(마이너스) key를 가상으로 생성하고 이를 이용하여 TraceId를 전달한다.

TransactionId는 전체 메시지의 유니크 ID이고, 이는 요청 데이터를 조회하는 검색 key이도 하다.


![](pinpoint정리1.PNG)

**2-1. 사례 질문**<br>
Pinpoint는 모든 요청을 추적하지 않고 샘플링한 데이터를 수집할 수 있다. 적은 양의 데이터만 수집해도 전체 애플리케이션의 상태를 확인하는데 무리가 없기 때문에 깊이의 제한을 둬도 문제가 없다. 또한 모든 요청을 다 캐치하면 속도가 느려지고 성능저하가 크게 발생하게 된다.

검색 속도는 알고리즘의 종류보다는, IO량에 더 큰 가중치가 있다. CPU vs IO가 되었을때, 보통은 IO가 병목 구간이다. 

서버맵의 알고리즘이 DFS에서 BFS 로 변경된 이유는 다음과 같다.
관계련 노드를 다 검색하니 느리다(느린 이유는 IO가 많아서), -> IO를 줄어야 겠다.
-> 검색 깊이 제한을 걸어야 겠다.(제한된 노드를 읽으면 IO가 줄어든다,) ->DFS에 검색 깊이 제한을 거니, 검색이 되지 않는 노드가 존재한다. 여러가지로 고민을 해보니 이를 DFS로 극복하기는 매우 힘들다..
-> BFS로 변경한다. -> 검색 되는 IO량이 줄으니 속도가 빨라졌다.

![](pinpoint정리2.PNG)

**2-2. 사례 질문**<br>
저는 TraceId 작동 사례만 보고 항상 트리구조인줄 알았다. 그래프 구조인게 맞는데 TraceId 작동 사례를 예로 들면 A->B->C->A 와 같은  순환관계가 발생할 수 있다.노드3번 or 노드4의 ParentSpanId가 10(노드1의 SPAN인 10이기 때문에) 이라면 순환관계

ParentSpanId=-1 은 추적의 시작 지점이다. 일종의 ROOT

결국 구조는 사용자의 아키텍처가 어떻게 되냐에 따라 결정된다. 

![](pinpoint정리3.PNG)

**3-1. Bytecode Instrument 질문** <br>

제 톰캣의 catalina.sh에 자바 옵션으로 javaagent를 설정함으로써 JVM이 구동될 때 이 JVM 안에서 특정 작업을 수행할 에이전트(Agent), 즉 요원을 지정할 수 있는 방식을 제공합니다. 

1번부터 5번까지 일련의 과정을 통해서 Agent가 작동하고 3~4번 transform에서 bytecode로 변환하는 부분이 있는데 Pinpoint에서는 직접 bytecode를 생성하기도 하고 라이브러리를 사용하기도 합니다.

추가적으로 저는 3~4번에서 바이트코드를 변환하기 위해서 ASM 라이브러리를 사용하는줄 알았는데, 어제 발표에서 Pinpoint의 새로운 기능으로 ASM기반 으로 해서 프로그래머가 직접 trace할 구간을 정할 수 있도록 한다고 합니다. 

 Pinpoint는 현재 Javassist를 사용하고 있습니다.
Javassist가 생산성이나, 사용성은 좋은데, 기능이 ASM에 비해 한계가 있어서, 추후 ASM으로 변경될예정입니다.
Pinpoint는 향후 이 변경을 쉽게 하기 위해서, Javassist의 API를 가능한 노출하지 않고, 별도의 추상화된 API를 제공하여 class를 수정하고 있습니다.

Plugin 기능은 사용자가 트레이스할 API을 직접 구현하여, 별도의 jar로 분리 시킬수 있습니다.
아래 패키지를 보시면 됩니다.
https://github.com/naver/pinpoint/tree/master/plugins/gson
아직 API가 완전히 고정된게 아니라. 추가로 변경될수 있습니다.

![](pinpoint정리4.PNG)

![](pinpoint정리5.PNG)

![](pinpoint정리6.PNG)

![](pinpoint정리7.PNG)

3-2. Bytecode Instrument 질문

아래 그림의 3번에서 해당 클래스가 메모리에 로딩될 때 Agent가 인터셉터로 before(), after()메소드를 주입시킵니다. 그리고 나온 결과를 네트워크 통신(TCP/UDP)을 통해 Collector로 전송시킵니다. 



TCP로는 DB같은 중요한 데이터를 전송하고 나머지는 UDP로 전송합니다.(어제 강의를 통해 들었는데 맞는지 확신이 안섭니다.) 그리고 4번에서 native code로 변환하고 실행이 됩니다. 

![](pinpoint정리8.PNG)

**4-1. 추가적인 질문**<br>
어제 Pinpoint의 발전방향에서 Java가 아닌 구간의 프로파일링으로써 WebServer 구간의 성능 수집을 말씀하셨습니다. 

제가 알고 있는 개념은 아래 그림과 같습니다. 요즘 톰캣이 많이 발전되서 일부 WebServer기능까지 담고 있어서 아래와 같이 표현을 했습니다. 

보통 WebServer는 정적인 데이터를 처리하는 서버이고 WebApplicationServer가 동적인 데이터를 처리하는 서버인데 WebServer 구간의 성능 수집이라 하시면 정적 데이터가 로딩되고 렌더링되는 성능 수집을 말씀하시는건가요?

또 톰캣을 통해 성능 수집을 하는 것을 Java구간의 프로파일링이라고 하는 건가요?

![](pinpoint질문1.PNG)

**4-2. 추가적인 질문**

Pinpoint의 동작 원리, 구조를 실제 코드를 통해 보려고 소스다운을 하고 열어보면서 공부는 하고 있지만 저 로직 흐름을 완전히 알지 못하기에 어디서부터 시작해야될지 사실 막막합니다. 

어제 Plugin을 말씀해주셨는데 구체적으로 어디의 plugin인가요? 다 찾아봤는데 마땅한 시작점을 발견하지 못했습니다. 