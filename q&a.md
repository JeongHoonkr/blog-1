1. TraceId 작동 사례 
하나의 Trace는 Span들의 집합이고 각각의 Span은 RPC가 도착할 때 처리할 작업을 나타내며 추적에 필요한 데이터를 가지고 있습니다. 그 데이터는 TraceId인데 TraceId는 TransactionId와 SpanId, ParentId로 이루어진 키의 집합입니다. 

이 TraceId를 HTTP 헤더에 넣어서 전송함으로써 각각의 노드 간의 관계를 정의 할 수 있습니다. 결국 Trace는 사용자의 한 요청에 따라 동작되는 모든 로직을 의미합니다. 그래서 한 Trace에 TransactionId가 같게 하는겁니다. 

![](pinpoint정리1.PNG)

2-1. 사례 질문
먼저 DFS와 BFS에 대해 잘못 알고 있는 부분이 있었습니다. 저는 보통 DFS를 재귀로 호출하는 형식으로 알고리즘을 짜서 느리다라고 생각했습니다. 하지만 전체 순회를 한다고 가정하에 DFS를 스택으로 구현한다면 BFS와 거의 똑같다고 합니다. 

즉, DFS, BFS의 속도 차이는 주어진 조건에 따라 다르다는것을 알았습니다.   

두번째로 Pinpoint는 모든 요청을 추적하지 않고 샘플링한 데이터를 수집할 수 있습니다. 적은 양의 데이터만 수집해도 전체 애플리케이션의 상태를 확인하는데 무리가 없기때문에 깊이의 제한을 둬도 문제가 없습니다. 또한 모든 요청을 다 캐치하면 

네트워크 대역폭이 다 차기 때문에 속도가 느려지도 오히려 성능저하가 크게 발생하게 됩니다. 

![](pinpoint정리2.PNG)

2-2. 사례 질문
저는 TraceId 작동 사례만 보고 항상 트리구조인줄 알았습니다. 그래프 구조인게 맞는데 TraceId 작동 사례를 예로 들면 노드3번 or 노드4번의 ParentSpanId가 -1이라면 그래프 구조가 되는겁니다. 

결국 구조는 사용자의 아키텍처가 어떻게 되냐에 따라 결정됩니다. 

