##1. REST기본 

REST는 근래에 들어 HTTP와 JSON을 함께 사용하여 OPEN API를 구현하는 방법으로 주류를 이루고 있으며, 대부분의 OPEN API는 이 REST 아키텍처를 기반으로 설계 및 구현되고 있다. 

REST원리를 따르는 시스템은 Restful이란 용어로 지칭된다.

REST는 크게 리소스, 메소드, 메세지 3가지 요소로 구성된다. <br>

ex) 이름이 Terry인 사용자를 생성한다
```
HTTP POST , http://myweb/users/
{
    "users" : {
        "name" : "terry"
    }
}
```
리소스  = http://myweb/users 형태의 URI <br>
HTTP POST메소드 = 생성한다<br>
메세지 = JSON 문서를 이용한 내용<br>

###1.1 HTTP 메소드

HTTP에는 여러 가지 메소드가 있지만, REST에서는 CRUD(Create, Read, Update, Delete)에 해당하는 4가지의 메소드만 사용한다.

| 메소드 | 의미 | Idempotent |
| -- | -- | -- |
| POST | Create | No |
| GET | Select | Yes |
| PUT | Update | Yes |
| DELETE | Delete | Yes |

Idempotent(멱등성)은 **여러 번 수행해도 결과가 같은 경우**를 의미한다. <br>
ex) a++은 Idempotent 하지 않다고 하지만(호출할 때마다 값이 증가하기 때문), a=4와 같은 명령은 반복적으로 수행해도 Idempotent 하다(값이 같기 때문).

POST 연산은 리소스를 추가하는 연산이기 때문에 Idempotent 하지 않지만, 나머지 GET, PUT, DELETE는 반복 수행해도 Idempotent하다. <br>GET의 경우 게시물의 조회 수 카운트를 늘려준다던가 하는 기능을 같이 수행했을 때는 Idempotent 하지 않은 메소드로 정의해야 한다. 

REST는 개별 API를 상태 없이 수행하게 된다. 그래서 해당 REST API를 다른 API와 함께 호출하다가 실패하였을 경우, 트랜잭션 복구를 위해서 다시 실행해야 하는 경우가 있는데, Idempotent 하지 않은 메소드의 경우는 기존 상태를 저장했다가 다시 원상복귀해줘야 하는 문제가 있지만, Idempotent 한 메소드의 경우에는 반복적으로 다시 메소드를 수행해주면 된다. <br>
ex) 게시물 조회를 하는 API가 있을 때 조회할 때마다 조회 수를 올리는 연산을 수행한다면 이 메소드는 Idempotent 하다고 볼 수 없고 조회하다가 실패하였을 때는 올라간 조회 수를 다시 -1 해줘야 한다. 즉, Idempotent 하지 않은 메소드에 대해서는 트랜잭션에 대한 처리에 주의가 필요하다. 

###1.2 REST의 리소스

REST는 리소스 지향 아키텍처 스타일이라는 정의답게 모든 것을 리소스, 즉 명사로 표현하며, 각 세부 리소스에는 ID를 붙인다.<br>
ex) 사용자라는 리소스 타입 : http://myweb/users <br>
terry라는 ID를 갖는 리소스 : http://myweb/users/terry<br>

REST의 리소스가 명사의 형태를 띄우다 보니 명령(Operation) 성격의 API를 정의하는 것에서 혼동이 올 수 있다. <br>
ex) "푸시 메세지를 보낸다"를 /myweb/sendpush 형태로 잘못 정의가 될 수 있지만 "푸시 메세지 요청을 생성한다"라는 형태로 정의를 변경하면, API포맷은 POST/myweb/push 형태와 같은 명사형으로 정의할 수 있다. <br>

**모든 형태의 명령이 이런식으로 정의가 가능한 것은 아니지만, 될 수 있으면 리소스 기반의 명사 형태로 정의하는 게 REST 형태의 디자인이 된다.**

사용자 생성 <br>
```
HTTP POST , http://myweb/users/
{
    "name" : "terry",
    "address" : "seoul"
}
```
http://myweb/users라는 리소스를 이름은 terry, 주소는 seoul이라는 내용(메세지)으로 HTTP POST를 이용해서 생성하는 정의 

조회 
```
HTTP Get, http://myweb/users/terry
```
생성된 리소스 중에서 http://myweb/users라는 사용자 리소스 중에 ID가 terry인 사용자 정보를 조회해오는 방식(조회이기 때문에 HTTP GET을 사용한다)

업데이트 
```
HTTP PUT, http://myweb/users/terry
{
    "name":"terry",
    "address":"suwon"
}
```
http://myweb/users라는 사용자 리소스 중에 ID가 terry인 사용자 정보에 대해서 주소를 suwon으로 수정하는 방식(수정은 HTTP메소드 중에 PUT을 사용한다) 

삭제
```
HTTP DELETE, http://myweb/users/terry
```
http://myweb/users라는 사용자 리소스 중에 ID가 terry인 사용자 정보를 상제하는 방법

###1.3 REST 특성
1. 유니폼 인터페이스(Uniform Interface)
    - REST는 HTTP 표준에만 따른다면 어떠한 기술이든지 사용할 수 있는 인터페이스 스타일이다.
2. 무상태성(Stateless)
    - '상태가 있다,없다'라는 의미는 사용자나 클라이언트의 컨텍스트를 서버 쪽에 유지하지 않는다는 의미로, 쉽게 표현하면 HTTP 세션과 같은 컨텍스트 저장소에 상태 정보를 저장하지 않는 형태를 의미한다.(상태 정보를 저장하지 않으면 각 API 서버는 들어오는 요청만을 들어오는 메세지로 처리하면 되며, 세션과 같은 컨텍스트 정보를 신경 쓸 필요가 없으므로 구현이 단순해진다.) 
3. 캐시 가능(Cacheable)
    - REST의 큰 특징 중의 하나는 HTTP라는 기존의 웹 표준을 그대로 사용하기 때문에 웹에서 사용하는 기존의 인프라를 그대로 활용할 수 있다는 점이다. HTTP의 리소스들을 웹 캐시 서버 등에 캐싱하는 것은 용량이나 성능 면에서 많은 장점이 있다. HTTP 프로토콜 표준에서 사용하는 Last-Modifyed태그나 E-Tag를 이용하면 캐싱을 구현할 수 있다. <br> ![](cache.PNG) <br>다음과 같이 HTTP GET을 Last-Modified 값과 함께 보냈을 때 콘텐츠에 변화가 없으면 REST 컴포넌트는 '304 Not Modified'를 반환하면 클라이언트는 자체 캐시에 저장된 값을 사용하게 된다. 
4. 자체 표현 구조(Self-descriptiveness)
    - REST의 또 다른 큰 특징 중 하나는 REST API 자체가 쉬워서 API 메세지만 보고도 이를 이해 할 수 있는 자체 표현 구조로 되어 있다는 것이다. 
5. 클라이언트 서버 구조 
    - REST 서버는 API를 제공하고 제공된 API를 이용해서 비즈니스 로직 처리 및 저장을 책임진다. 클라이언트는 사용자 인증이나 컨텍스트(세션, 로그인 정보)를 직접 관리하고 책임지는 구조로 역할이 나누어지고 있다. 이렇게 각각의 역할이 확실하게 구분되면서 개발 관점에서 클라이언트와 서버에서 개발해야 할 내용이 명확해지고 서로의 개발에서 의존성이 줄어들게 된다.
6. 계층형 구조 
    - 클라이언트로서는 REST API 서버만 호출한다. 그러나 서버는 다중 계층으로 구성될 수 있다. 순수 비즈니스 로직을 수행하는 API 서버와 그 앞단에 사용자 인증, 암호화, 로드 밸런싱을 하는 계층을 추가해서 구조상의 유연성을 둘 수 있는데 이는 마이크로 서비스 아키텍처의 API Gateway나 HAProxy Apache와 같은 Reverse Proxyt를 이용해서 구현하는 경우가 많다. 


###1.4 REST 안티 패턴 

1. GET이나 POST를 이용한 터널링 <br>
ex) http://myweb/users?method=update&id=terry <br> 메소드의 실제 동작은 리소스를 업데이트 하는 내용인데, HTTP PUT을 사용하지 않고 GET에 쿼리 파라미터로 넘겨서 명시했다. 

    ex) Insert(Create)성 오퍼레이션이 아닌데도 불구하고 JSON body에 오퍼레이션 명을 넘기는 형태
```
HTTP POST, http://myweb/users
{
    "getuser" : 
    {
        "id":"terry"
    }
}
```
2. Self-descriptiveness 속성을 사용하지 않음
    - 자체 표현 구조를 갉아먹는 가장 대표적인 사례가 GET, POST를 이용한 터널링 구조
3. HTTP 응답 코드를 사용하지 않음
    - 1~2개의 HTTP 응답 코드만 사용하는 문제 

##2. REST API 디자인 가이드


###2.1 REST URI는 단순하고 직관적으로 만들자 

최대 2단계 정도로 간단하게 만드는 것이 이해하기 편하다.
```
/dogs/
/dogs/1234
```

URI에 리소스명은 동사보다는 명사를 사용한다. REST API는 리소스에 대해서 행동을 정의하는 형태를 사용한다. 
```
POST /dogs
```
위는 /dogs라는 리소스를 생성하라는 의미로, URL은 HTTP 메소드에 의해 CRUD(생성, 읽기, 수정, 삭제)의 대상이 되는 개체(명사)라야 한다. 

잘못된 예들은 다음과 같다.
```
HTTP POST: /getDogs
HTTP POST: /setDogsOwner
```
위의 예제는 HTTP POST로 정의하지 않고 get/set 등의 행위를 URL에 붙인 경우인데, 좋지 않다. <br> 그리고 될 수 있으면 단수형 명사(/dog) 보다는 복수형 명사(/dogs)를 사용하는 것이 의미상 표현하기가 더 좋다.

```
HTTP GET: /dogs
HTTP POST: /dogs/{puppy}/owner/{terry}
```

일반적으로 권고하는 디자인은 다음과 같다.

| 리소스 | POST | GET | PUT | DELETE |
| -- | -- | -- | -- | -- |
| 리소 | create | read | update | delete |
| /dogs | 새로운 dogs 등록 | dogs 목록을 반환 | Bulk로 여러 dogs 정보를 업데이트 | 모든 dogs 정보를 삭제 |
| /dogs/baduk | 에러 | baduk이라는 이름의 dogs 정보를 반환 | baduk이라는 이름의 dogs 정보를 업데이트 | baduk이라는 이름의 dogs 정보를 삭제 |

###2.2 리소스 간의 관계를 표현하는 방법

REST 리소스 간에는 연관 관계가 있을 수 있다.예를 들어 사용자가 소유한 디바이스 목록이나 사용자가 가진 강아지들 등이 예가 될 수 있는데, 사용자-디바이스 또는 사용자-강아지 등 각각의 리소스 간의 관계를 표현하는 방법에는 여러 가지가 있다.

**옵션 1 : 서브 리소스로 표현하는 방법**<br>
예를 들어 사용자의 휴대전화 디바이스 목록을 표현해보면 다음과 같이 /terry라는 사용자가 가진 디바이스 목록을 반환하는 방법이 있다. 
```
/"리소스명"/"리소스 id"/"관계가 있는 다른 리소스명" 형태 
HTTP GET: /users/{userid}/devices
예)/users/terry/devices
```

**옵션 2 : 서브 리소스에 관계를 명시하는 방법** <br>
만약에 관계명이 복잡하다면 이를 명시적으로 표현하는 방법이 있다. 예를 들어 사용자가 '좋아하는' 디바이스 목록을 표현해보면 다음은 terry라는 사용자가 좋아하는 디바이스 목록을 반환하는 방식이다.
```

```