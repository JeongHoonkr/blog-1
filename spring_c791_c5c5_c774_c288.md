# Spring 작업 이슈

##1. 통합테스트 애노테이션 정리

###Spring 
```
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(classes = Application.class) 

@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration("/app-config.xml")
```
`@ContextConfiguration`은 통합 테스트에서 클래스 레벨 메타데이터(xml 파일 or javaConfig 파일)를 정의한다. 다시 말해, context를 로드하는데 사용되는 annotated class(@Configuration 클래스)나 application context resource locations(classpath에 위치한 XML 설정 파일)들을 선언한다.

또한 `@ContextConfiguration`은 ContextLoader 전략을 사용할 수 있다. 하지만 일반적으로 로더를 직접 명시할 필요는 없다. default loader가 initializers 뿐만 아니라 resource locations 또는 annotated classes를 지원하기 때문이다. 

---

**문제 발생**<br>
Spring Boot에서 `@ContextConfiguration(classes = Application.class)`만 설정했더니 
```
[main] DEBUG org.springframework.core.type.classreading.AnnotationAttributesReadingVisitor -
Failed to class-load type while reading annotation metadata. 
This is a non-fatal error, but certain annotation metadata may be unavailable.

java.lang.ClassNotFoundException:
org.springframework.data.web.config.EnableSpringDataWebSupport
...
java.lang.ClassNotFoundException:
org.springframework.security.config.annotation.web.configuration.EnableWebSecurity
...
```
위와 같은 에러뿐만 아니라 기본적인 Autowired 설정도 안되고, BeanCreationException도 발생했다.
원인은 애노테이션이 classpath에 없기 때문에 클래스가 로드될 때 JVM이 drop 시켜서 발생한 문제였다.

**해결 방법1**<br>
Spring Boot에서는 기존의 `@ContextConfiguration` 대신 `@SpringApplicationConfiguration`을 제공한다. ApplicationContext 설정을 `@SpringApplicationConfiguration`으로 사용하면 SpringApplication 으로 생성되고 추가적인 Spring Boot feature들을 얻을 수 있다.

**해결 방법2**<br>
```
@ContextConfiguration(classes = Application.class, 
loader = SpringApplicationContextLoader.class)
```
그런데 1.4부터 SpringApplicationContextLoader가 Deprecated 되었다. 

**해결 방법3**<br>
```
@ContextConfiguration(classes = Application.class, 
initializers = ConfigFileApplicationContextInitializer.class)
```
ConfigFileApplicationContextInitializer는 Spring Boot application.properties파일을 로드해 테스트 코드에 적용한다. `@SpringApplicationConfiguration`가 제공하는 full feature들이 필요 없을 때 사용된다.<br><br>


cf) spring boot 1.4<br>
직접적인 Configuration 설정 없이도 `@*Test` 애노테이션이 자동으로 primary configuration을 찾는다(테스트가 포함된 패키지로부터 `@SpringBootApplication`또는 `@SpringBootConfiguration` 애노테이션 클래스를 찾는다). 


###Spring Boot
```
// 방법1
@RunWith(SpringJUnit4ClassRunner.class)
@SpringApplicationConfiguration(classes = Application.class)

// 방법2 (1.4부터 SpringApplicationContextLoader Deprecated 됌)
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(classes = Application.class, loader = SpringApplicationContextLoader.class)

// 방법3
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(classes = Application.class, 
initializers = ConfigFileApplicationContextInitializer.class)

// 방법4 (spring boot 1.4부터 가능)
@RunWith(SpringRunner.class)
@SpringBootTest(webEnvironment=WebEnvironment.RANDOM_PORT)
```
cf) 방법4에서 `@SpringBootTest`에서 classes 속성을 생략하면 inner-classes에서 `@Configuration`을 제일 먼저 로드하려 시도하고, 없으면 `@SpringBootApplication` class를 찾는다.


**@WebApplicationContext**<br>
WebApplicationContext을 생성할 수 있게 해준다. 
```
@RunWith(SpringJUnit4ClassRunner.class)
@SpringApplicationConfiguration(classes = Application.class)
@WebAppConfiguration
public class AccountControllerTest {

  @Autowired
  WebApplicationContext wac;
  MockMvc mockMvc;
  
  @Before
  public void setUp() {
      mockMvc = MockMvcBuilders.webAppContextSetup(wac).build();
  }
  
  ...
}
```

##2. dataSource
메이븐 pom.xml에서 에서 spring-boot-starter-data-jpa 를 추가하면 그안에 spring-boot-starter-jdbc가 있고 그 안에 tomcat-jdbc가 있다.<br>
Spring Boot에서는 DataSource 관리를 위한 구현체로써 tomcat-jdbc(The Tomcat JDBC Pool) 을 default로 제공한다.<br>

![](스크린샷 2016-05-21 오후 3.32.23.jpg)
근데 실서버에 배포 했을 때 위와 같은 에러가 반복해서 발생했고 그 주기도 일정치 않아서 재연이 쉽지 않았다. `validationQuery: select 1`을 설정했음에도 connection이 자꾸 닫히는 문제가 발생했다.
```
[2016-05-19 17:37:40.187] boot - 11886 ERROR [http-nio-8080-exec-3] --- SqlExceptionHelper: No operations allowed after connection closed.
[2016-05-19 17:37:40.188] boot - 11886 ERROR [http-nio-8080-exec-3] --- TransactionInterceptor: Application exception overridden by rollback exception
javax.persistence.PersistenceException: org.hibernate.exception.JDBCConnectionException: could not prepare statement
at org.hibernate.jpa.spi.AbstractEntityManagerImpl.convert(AbstractEntityManagerImpl.java:1763)
at org.hibernate.jpa.spi.AbstractEntityManagerImpl.convert(AbstractEntityManagerImpl.java:1677)
at org.hibernate.jpa.internal.QueryImpl.getResultList(QueryImpl.java:458)
at org.hibernate.jpa.criteria.compile.CriteriaQueryTypeQueryAdapter.getResultList(CriteriaQueryTypeQueryAdapter.java:67)
at org.springframework.data.jpa.repository.support.SimpleJpaRepository.findAll(SimpleJpaRepository.java:323)
at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
at java.lang.reflect.Method.invoke(Method.java:497)
at org.springframework.data.repository.core.support.RepositoryFactorySupport$QueryExecutorMethodInterceptor.executeMethodOn(RepositoryFactorySupport.java:483)
at org.springframework.data.repository.core.support.RepositoryFactorySupport$QueryExecutorMethodInterceptor.doInvoke(RepositoryFactorySupport.java:468)
at org.springframework.data.repository.core.support.RepositoryFactorySupport$QueryExecutorMethodInterceptor.invoke(RepositoryFactorySupport.java:440)
at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179)
at org.springframework.data.projection.DefaultMethodInvokingMethodInterceptor.invoke(DefaultMethodInvokingMethodInterceptor.java:61)
at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179)
at org.springframework.transaction.interceptor.TransactionInterceptor$1.proceedWithInvocation(TransactionInterceptor.java:99)
at org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:281)
at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:96)
at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179)
at org.springframework.dao.support.PersistenceExceptionTranslationInterceptor.invoke(PersistenceExceptionTranslationInterceptor.java:136)
at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179)
at org.springframework.data.jpa.repository.support.CrudMethodMetadataPostProcessor$CrudMethodMetadataPopulatingMethodInterceptor.invoke(CrudMethodMetadataPostProcessor.java:131)
```
그래서 해결책으로 hikari cp를 사용했다.
```
//관련 의존성 추가
<dependency>
    <groupId>com.zaxxer</groupId>
    <artifactId>HikariCP</artifactId>
    <version>2.4.6</version>
</dependency>

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-configuration-processor</artifactId>
    <optional>true</optional>
</dependency>

//설정 추가 
@Configuration
@ConfigurationProperties(prefix = "hikari.datasource")
public class JpaConfig extends HikariConfig {

    @Bean
    public DataSource dataSource() throws SQLException{

        return new HikariDataSource(this);
    }
}

// yml 추가
hikari:
  datasource:
    jdbcUrl: jdbc:mysql://blabla
    driverClassName: com.mysql.jdbc.Driver
    username: blabla
    password: blabla
    maximum-pool-size: 5
    connection-test-query: select 1
```

**but 설정파일에 hikari 의존이 생기는 건 좋지 않다.** 
```
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-jpa</artifactId>
    <exclusions>
      <exclusion>
        <groupId>org.apache.tomcat</groupId>
        <artifactId>tomcat-jdbc</artifactId>
      </exclusion>
    </exclusions>
</dependency>

```
위와 같이 tomcat에서 제공하는 기본 dataSource를 지우면 boot에서 자동으로 hikari cp로 설정된다. 따라서 JpaConfig 파일도 필요 없게 되고 yml에서 hikari를 지워도 된다. 


---
**2016.08.12 추가**<br>
Spring Boot 1.4부터는 db 프로파일에 `spring.datasource.hikari`를 명시적으로 작성할 수 있게 됐다.

##3. request url에 문자열 ".t"을 확장자로 인식
```
@RequestMapping(value = "/messages/receiverUsername/{receiverUsername:.+}", method = RequestMethod.GET)
```
위와 같이 정규식으로 모든 문자열을 (. 포함) 받겠다고 명시했음에도 .t는 인식이 안되는 문제가 발생했다. <br>

이유는 .t라는 확장자가 있기 때문에 아래와 같이 설정에서 mediaType을 json으로 직접 명시해주면 해결이 가능하다. 
```
@Override
public void configureContentNegotiation(ContentNegotiationConfigurer configurer) {
    configurer.favorPathExtension(true);
    configurer.useJaf(false);
    configurer.ignoreAcceptHeader(true);
    configurer.mediaType("json", MediaType.APPLICATION_JSON);
}
```

##4. Spring MVC Test 
Spring Framework 4.2.6에서 Spring MVC Test를 처음 생성하다 다음과 같은 에러가 발생했다.
```
java.lang.NoClassDefFoundError: javax/servlet/SessionCookieConfig
```

문제는 org.springframework.mock.web에 있는 mock set들은 Servlet 3.0 API를 기반으로 동작하는데 현재 프로젝트 Servlet 버전은 2.5였다.


```
변경 전
<dependency>
    <groupId>javax.servlet</groupId>
    <artifactId>javax.servlet-api</artifactId>
    <version>2.5</version>
    <scope>provided</scope>
</dependency>

변경 후
<dependency>
    <groupId>javax.servlet</groupId>
    <artifactId>javax.servlet-api</artifactId>
    <version>3.1.0</version>
    <scope>provided</scope>
</dependency>
```
The Spring 4.0.1 reference documentation is now more clear about the Mocks: **Servlet 3.0+ is strongly recommended and a prerequisite in Spring's test and mock packages for test setups in development environments.**

##5. 날짜
```
// 기존 날짜 데이터 처리 방식
long plusDay = xxxSchedule.getExecutionDate().getTime() + TimeUnit.DAYS.toMillis(extendDays);

xxxSchedule.setRegisterDate(Date.from(Instant.now()));
xxxSchedule.setExecutionDate(new Date(plugDay));

// 자바8 현재 날짜 구하기
LocalDateTime.now()
LocalDate.now().format(DateTimeFormatter.ofPattern("yyyyMMdd"));

// 타임스탬프에서 날짜 가져오기
Long time = 1470651527000L;
DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
String format = dateFormat.format(time);
```

##6. Mockito
**verify**
```
verify(xxxRepository, never()).save(any(xxx.class));
```
`never()` : 어떤 조건에 따라 호출되면 안되는 경우, 진짜 호출이 안되는지 확인.<br>
`<T> T any(Class<T> clazz)`: anyObject와는 다르게 클래스를 지정할 수 있다.

**spy**<br>
해당 서비스안에 있는 일반 메서드를 `when().thenReturn()`을 통해 제어하고 싶을 때 서비스를 spy로 만들어서 할 수 있다.
```
xxxService xxxServiceSpy = Mockito.spy(xxxService);
```
**ArgumentCapture**<br>
참고 : http://stackoverflow.com/questions/12295891/how-to-use-argumentcaptor-for-stubbing<br>
stub을 만들지 않고, 메서드가 호출됐는지 확인하는 것과 인자가 정확한지 확인하고 싶을 때 ArgumentCaptor방식을 사용할 수 있다.
```
ArgumentCaptor<SomeClass> argumentCaptor = ArgumentCaptor.forClass(SomeClass.class);
verify(someObject).doSomething(argumentCaptor.capture());
assertNull(argumentCaptor.getValue().getXXX());
```

##7. YAML
기존 spring 프로젝트에서 yml 설정을 하기 위해서 먼저 의존성을 추가해준다.
```
<dependency>
    <groupId>org.yaml</groupId>
    <artifactId>snakeyaml</artifactId>
    <version>1.17</version>
</dependency>
```
그리고 서블릿 컨텍스트에 yaml 설정을 추가해준다.
```
<beans xmlns="http://www.springframework.org/schema/beans" xmlns:mvc="http://www.springframework.org/schema/mvc"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="
		http://www.springframework.org/schema/beans
		http://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/mvc
        http://www.springframework.org/schema/mvc/spring-mvc.xsd
		http://www.springframework.org/schema/context 
		http://www.springframework.org/schema/context/spring-context.xsd">
        
<bean id="yamlProperties" class="org.springframework.beans.factory.config.YamlPropertiesFactoryBean">
        <property name="resources" value="classpath:application.yml" />
</bean>

<context:property-placeholder properties-ref="yamlProperties" />
```
cf) spring boot에서는 classpath 에 application.yml 을 추가 하면 자동으로 boot가 스캔하기 때문에 따로 설정이 필요없다.
```
	<build>
		<!-- Turn on filtering by default for application properties -->
		<resources>
			<resource>
				<directory>${basedir}/src/main/resources</directory>
				<filtering>true</filtering>
				<includes>
					<include>**/application.yml</include>
					<include>**/application.properties</include>
				</includes>
			</resource>
			<resource>
				<directory>${basedir}/src/main/resources</directory>
				<excludes>
					<exclude>**/application.yml</exclude>
					<exclude>**/application.properties</exclude>
				</excludes>
			</resource>
		</resources>
    </build>
```
**application.yml 작성 예**
```
spring:
  profiles.active: local

---
spring:
  velocity:
    properties.input.encodig: UTF-8
    properties.output.encodig: UTF-8
    cache: false
  jpa:
    show-sql: true
    database-platform: org.hibernate.dialect.MySQL5Dialect
    hibernate:
      ddl-auto: validate
      naming-strategy: org.hibernate.cfg.ImprovedNamingStrategy
    properties:
      hibernate:
        temp:
          use_jdbc_metadata_defaults: false
---
spring:
  profiles: h2-db

  datasource:
    jdbcUrl: jdbc:h2:mem:AZ;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE
    driverClassName: org.h2.Driver
    username: xxx
    password: xxx
    maxWait: 1000

  h2:
    console:
      enabled: true
      path: /h2-console

  jpa:
    show-sql: false
    database-platform: org.hibernate.dialect.H2Dialect
    hibernate:
      ddl-auto: create
      naming-strategy: org.hibernate.cfg.ImprovedNamingStrategy
    properties:
      hibernate:
        temp:
          use_jdbc_metadata_defaults: false
logging:
  level: info

---
spring:
  profiles: real-db

  datasource:
    jdbcUrl: xxx
    driverClassName: com.mysql.jdbc.Driver
    username: xxx
    password: xxx
    maximum-pool-size: 5
    connection-test-query: select 1
---
spring:
  profiles: aws-db-test

  datasource:
    jdbcUrl: xxx
    driverClassName: com.mysql.jdbc.Driver
    username: xxx
    password: xxx
    maximum-pool-size: 5
    connection-test-query: select 1
---
spring:
  profiles: local

  datasource:
    url: xxx
    driverClassName: com.mysql.jdbc.Driver
    username: xxx
    password: xxx
    maxWait: 1000
    validationQuery: select 1
```

##8. 기존 xml 설정을 JavaConfig로 변경하기
먼저 web.xml에서 contextConfigLocation을 xml 파일 위치 대신 AppConfig 위치로 변경해준다.
```
<!-- Processes application requests -->
<servlet>
    <servlet-name>appServlet</servlet-name>
    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
    <init-param>
        <param-name>contextConfigLocation</param-name>
        <param-value>
            classpath:spring/servlet-context.xml
        </param-value>
    </init-param>
    <load-on-startup>1</load-on-startup>
</servlet>
```
```
<!-- Processes application requests -->
<servlet>
    <servlet-name>appServlet</servlet-name>
    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
    <init-param>
        <param-name>contextClass</param-name>
        <param-value>
            org.springframework.web.context.support.AnnotationConfigWebApplicationContext
        </param-value>
    </init-param>
    <init-param>
        <param-name>contextConfigLocation</param-name>
        <param-value>
            (패키지명)xxx.xxx.xxx.xxx.config.AppConfig
        </param-value>
    </init-param>
    <load-on-startup>1</load-on-startup>
</servlet>
```
그리고 ContextLoaderListener가 자동으로 생성하는 컨텍스트의 클래스는 기본적으로 `XmlWebApplicationContext`다. 이를 다른 애플리케이션 컨텍스트 구현 클래스로 변경하고 싶으면 contextClass 파라미터를 이용해 지정해주면 된다.

두번째로 AppConfig 파일에 기존 xml에 있던 설정들을 옮긴다. 
```
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang.StringUtils;
import org.springframework.beans.BeansException;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.config.YamlProcessor;
import org.springframework.beans.factory.config.YamlPropertiesFactoryBean;
import org.springframework.boot.yaml.SpringProfileDocumentMatcher;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
import org.springframework.context.EnvironmentAware;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.ImportResource;
import org.springframework.context.support.PropertySourcesPlaceholderConfigurer;
import org.springframework.core.env.Environment;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;
import org.springframework.scheduling.annotation.EnableAsync;
import org.springframework.scheduling.annotation.EnableScheduling;
import org.springframework.transaction.annotation.EnableTransactionManagement;
import org.springframework.web.client.RestTemplate;

import java.io.IOException;
import java.util.Properties;

@Configuration
@Slf4j
@EnableJpaRepositories(basePackages = "xxx.xxx.xxx.xxx", transactionManagerRef = "xxxTransactionManager")
@EnableScheduling
@EnableAsync
@EnableTransactionManagement
@ComponentScan("xxx.xxx.xxx")
@ImportResource({"classpath:spring/applicationContext-db.xml", "classpath:spring/applicationContext-jpa.xml"})
public class AppConfig implements EnvironmentAware, ApplicationContextAware {
	private ApplicationContext ctx;
	private Environment env;

	@Bean
	RestTemplate getRestTemplate() {
		return new RestTemplate();
	}

	@Bean
	public YamlProcessor.DocumentMatcher documentMatcher() {
		String[] profile = getProfile();
		log.info("ActiveProfile: {}", (Object[]) profile);
		return new SpringProfileDocumentMatcher(profile);
	}

	@Bean(name = "yamlProperties")
	public YamlPropertiesFactoryBean yamlPropertiesFactoryBean(YamlProcessor.DocumentMatcher documentMatcher) throws IOException {
		YamlPropertiesFactoryBean yamlPropertiesFactoryBean = new YamlPropertiesFactoryBean();
		yamlPropertiesFactoryBean.setResources(ctx.getResources("classpath:application.yml"));
		yamlPropertiesFactoryBean.setDocumentMatchers(documentMatcher);
		return yamlPropertiesFactoryBean;
	}

	@Bean 
	public PropertySourcesPlaceholderConfigurer propertySourcesPlaceholderConfigurer(@Qualifier("yamlProperties") Properties yamlProperties) {
		PropertySourcesPlaceholderConfigurer p = new PropertySourcesPlaceholderConfigurer();
		p.setProperties(yamlProperties);
		return p;
	}

	@Override
	public void setEnvironment(Environment environment) {
		this.env = environment;
	}
	@Override
	public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
		this.ctx = applicationContext;
	}

	private String[] getProfile() {
		String[] activeProfiles = env.getActiveProfiles();
		if (activeProfiles != null) {
			return activeProfiles;
		}

		Properties properties = System.getProperties();
		String profileActive = properties.getProperty("spring.profiles.active");

		return new String[] { StringUtils.defaultString(profileActive, "dev") };
	}
}
```

##9. Mybatis db 언더바 사용된 컬럼과 자바 카멜케이스 변수 자동 매핑
application.yml
```
mybatis:
  mapper-locations: classpath:mybatis/mapper/*.xml
  configuration:
    map-underscore-to-camel-case: true
```

##10. @RequestParam값이 Optional일때 DefaultValue 적용
```
@RequestParam(value = "bongsoo", required = false) int bongsoo
```
int형이기 때문에 값이 없을때 null일 수 없다. 그래서 defaultValue를 미리 지정해주는게 좋다. 
```
@RequestParam(value = "bongsoo", required = false, defaultValue="0") int bongsoo
```
