# Spring 작업 이슈

##1. dataSource
메이븐 pom.xml에서 에서 spring-boot-starter-data-jpa 를 추가하면 그안에 spring-boot-starter-jdbc가 있고 그 안에 tomcat-jdbc가 있다.<br>
Spring Boot에서는 DataSource 관리를 위한 구현체로써 tomcat-jdbc(The Tomcat JDBC Pool) 을 default로 제공한다.<br>

![](스크린샷 2016-05-21 오후 3.32.23.jpg)
근데 실서버에 배포 했을 때 위와 같은 에러가 반복해서 발생했고 그 주기도 일정치 않아서 재연이 쉽지 않았다. `validationQuery: select 1`을 설정했음에도 connection이 자꾸 닫히는 문제가 발생했다.
```
[2016-05-19 17:37:40.187] boot - 11886 ERROR [http-nio-8080-exec-3] --- SqlExceptionHelper: No operations allowed after connection closed.
[2016-05-19 17:37:40.188] boot - 11886 ERROR [http-nio-8080-exec-3] --- TransactionInterceptor: Application exception overridden by rollback exception
javax.persistence.PersistenceException: org.hibernate.exception.JDBCConnectionException: could not prepare statement
at org.hibernate.jpa.spi.AbstractEntityManagerImpl.convert(AbstractEntityManagerImpl.java:1763)
at org.hibernate.jpa.spi.AbstractEntityManagerImpl.convert(AbstractEntityManagerImpl.java:1677)
at org.hibernate.jpa.internal.QueryImpl.getResultList(QueryImpl.java:458)
at org.hibernate.jpa.criteria.compile.CriteriaQueryTypeQueryAdapter.getResultList(CriteriaQueryTypeQueryAdapter.java:67)
at org.springframework.data.jpa.repository.support.SimpleJpaRepository.findAll(SimpleJpaRepository.java:323)
at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
at java.lang.reflect.Method.invoke(Method.java:497)
at org.springframework.data.repository.core.support.RepositoryFactorySupport$QueryExecutorMethodInterceptor.executeMethodOn(RepositoryFactorySupport.java:483)
at org.springframework.data.repository.core.support.RepositoryFactorySupport$QueryExecutorMethodInterceptor.doInvoke(RepositoryFactorySupport.java:468)
at org.springframework.data.repository.core.support.RepositoryFactorySupport$QueryExecutorMethodInterceptor.invoke(RepositoryFactorySupport.java:440)
at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179)
at org.springframework.data.projection.DefaultMethodInvokingMethodInterceptor.invoke(DefaultMethodInvokingMethodInterceptor.java:61)
at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179)
at org.springframework.transaction.interceptor.TransactionInterceptor$1.proceedWithInvocation(TransactionInterceptor.java:99)
at org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:281)
at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:96)
at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179)
at org.springframework.dao.support.PersistenceExceptionTranslationInterceptor.invoke(PersistenceExceptionTranslationInterceptor.java:136)
at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179)
at org.springframework.data.jpa.repository.support.CrudMethodMetadataPostProcessor$CrudMethodMetadataPopulatingMethodInterceptor.invoke(CrudMethodMetadataPostProcessor.java:131)
```
그래서 해결책으로 hikari cp를 사용했다.
```
//관련 의존성 추가
<dependency>
    <groupId>com.zaxxer</groupId>
    <artifactId>HikariCP</artifactId>
    <version>2.4.6</version>
</dependency>

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-configuration-processor</artifactId>
    <optional>true</optional>
</dependency>

//설정 추가 
@Configuration
@ConfigurationProperties(prefix = "hikari.datasource")
public class JpaConfig extends HikariConfig {

    @Bean
    public DataSource dataSource() throws SQLException{

        return new HikariDataSource(this);
    }
}

// yml 추가
hikari:
  datasource:
    jdbcUrl: jdbc:mysql://blabla
    driverClassName: com.mysql.jdbc.Driver
    username: blabla
    password: blabla
    maximum-pool-size: 5
    connection-test-query: select 1
```

**but 설정파일에 hikari 의존이 생기는 건 좋지 않다.** 
```
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-jpa</artifactId>
    <exclusions>
      <exclusion>
        <groupId>org.apache.tomcat</groupId>
        <artifactId>tomcat-jdbc</artifactId>
      </exclusion>
    </exclusions>
</dependency>

```
위와 같이 tomcat에서 제공하는 기본 dataSource를 지우면 boot에서 자동으로 hikari cp로 설정된다. 따라서 JpaConfig 파일도 필요 없게 되고 yml에서 hikari를 지워도 된다. 

##2. request url에 문자열 ".t"을 확장자로 인식
```
@RequestMapping(value = "/messages/receiverUsername/{receiverUsername:.+}", method = RequestMethod.GET)
```
위와 같이 정규식으로 모든 문자열을 (. 포함) 받겠다고 명시했음에도 .t는 인식이 안되는 문제가 발생했다. <br>

이유는 .t라는 확장자가 있기 때문에 아래와 같이 설정에서 mediaType을 json으로 직접 명시해주면 해결이 가능하다. 
```
@Override
public void configureContentNegotiation(ContentNegotiationConfigurer configurer) {
    configurer.favorPathExtension(true);
    configurer.useJaf(false);
    configurer.ignoreAcceptHeader(true);
    configurer.mediaType("json", MediaType.APPLICATION_JSON);
}
```

##3. Spring MVC Test 
Spring Framework 4.2.6에서 Spring MVC Test를 처음 생성하다 다음과 같은 에러가 발생했다.
```
java.lang.NoClassDefFoundError: javax/servlet/SessionCookieConfig
```

문제는 org.springframework.mock.web에 있는 mock set들은 Servlet 3.0 API를 기반으로 동작하는데 현재 프로젝트 Servlet 버전은 2.5였다.


```
변경 전
<dependency>
    <groupId>javax.servlet</groupId>
    <artifactId>javax.servlet-api</artifactId>
    <version>2.5</version>
    <scope>provided</scope>
</dependency>

변경 후
<dependency>
    <groupId>javax.servlet</groupId>
    <artifactId>javax.servlet-api</artifactId>
    <version>3.1.0</version>
    <scope>provided</scope>
</dependency>
```
The Spring 4.0.1 reference documentation is now more clear about the Mocks: **Servlet 3.0+ is strongly recommended and a prerequisite in Spring's test and mock packages for test setups in development environments.**

##4. 날짜
```
long plusDay = xxxSchedule.getExecutionDate().getTime() + TimeUnit.DAYS.toMillis(extendDays);

xxxSchedule.setRegisterDate(Date.from(Instant.now()));
xxxSchedule.setExecutionDate(new Date(plugDay));
```

##5. Mockito
**verify**
```
verify(xxxRepository, never()).save(any(xxx.class));
```
`never()` : 어떤 조건에 따라 호출되면 안되는 경우, 진짜 호출이 안되는지 확인.<br>
`<T> T any(Class<T> clazz)`: anyObject와는 다르게 클래스를 지정할 수 있다.

**spy**<br>
해당 서비스안에 있는 일반 메서드를 `when().thenReturn()`을 통해 제어하고 싶을 때 서비스를 spy로 만들어서 할 수 있다.
```
xxxService xxxServiceSpy = Mockito.spy(xxxService);
```
**ArgumentCapture**<br>
참고 : http://stackoverflow.com/questions/12295891/how-to-use-argumentcaptor-for-stubbing<br>
stub을 만들지 않고, 메서드가 호출됐는지 확인하는 것과 인자가 정확한지 확인하고 싶을 때 ArgumentCaptor방식을 사용할 수 있다.
```
ArgumentCaptor<SomeClass> argumentCaptor = ArgumentCaptor.forClass(SomeClass.class);
verify(someObject).doSomething(argumentCaptor.capture());
assertNull(argumentCaptor.getValue().getXXX());
```

##6. YAML
기존 spring 프로젝트에서 yml 설정을 하기 위해서 먼저 의존성을 추가해준다.
```
<dependency>
    <groupId>org.yaml</groupId>
    <artifactId>snakeyaml</artifactId>
    <version>1.17</version>
</dependency>
```
그리고 서블릿 컨텍스트에 yaml 설정을 추가해준다.
```
<beans xmlns="http://www.springframework.org/schema/beans" xmlns:mvc="http://www.springframework.org/schema/mvc"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="
		http://www.springframework.org/schema/beans
		http://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/mvc
        http://www.springframework.org/schema/mvc/spring-mvc.xsd
		http://www.springframework.org/schema/context 
		http://www.springframework.org/schema/context/spring-context.xsd">
        
<bean id="yamlProperties" class="org.springframework.beans.factory.config.YamlPropertiesFactoryBean">
        <property name="resources" value="classpath:application.yml" />
</bean>

<context:property-placeholder properties-ref="yamlProperties" />
```
cf) spring boot에서는 classpath 에 application.yml 을 추가 하면 자동으로 boot가 스캔하기 때문에 따로 설정이 필요없다.
```
	<build>
		<!-- Turn on filtering by default for application properties -->
		<resources>
			<resource>
				<directory>${basedir}/src/main/resources</directory>
				<filtering>true</filtering>
				<includes>
					<include>**/application.yml</include>
					<include>**/application.properties</include>
				</includes>
			</resource>
			<resource>
				<directory>${basedir}/src/main/resources</directory>
				<excludes>
					<exclude>**/application.yml</exclude>
					<exclude>**/application.properties</exclude>
				</excludes>
			</resource>
		</resources>
    </build>
```
**application.yml 작성 예**
```
spring:
  profiles.active: local

---
spring:
  velocity:
    properties.input.encodig: UTF-8
    properties.output.encodig: UTF-8
    cache: false
  jpa:
    show-sql: true
    database-platform: org.hibernate.dialect.MySQL5Dialect
    hibernate:
      ddl-auto: validate
      naming-strategy: org.hibernate.cfg.ImprovedNamingStrategy
    properties:
      hibernate:
        temp:
          use_jdbc_metadata_defaults: false
---
spring:
  profiles: h2-db

  datasource:
    jdbcUrl: jdbc:h2:mem:AZ;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE
    driverClassName: org.h2.Driver
    username: xxx
    password: xxx
    maxWait: 1000

  h2:
    console:
      enabled: true
      path: /h2-console

  jpa:
    show-sql: false
    database-platform: org.hibernate.dialect.H2Dialect
    hibernate:
      ddl-auto: create
      naming-strategy: org.hibernate.cfg.ImprovedNamingStrategy
    properties:
      hibernate:
        temp:
          use_jdbc_metadata_defaults: false
logging:
  level: info

---
spring:
  profiles: real-db

  datasource:
    jdbcUrl: xxx
    driverClassName: com.mysql.jdbc.Driver
    username: xxx
    password: xxx
    maximum-pool-size: 5
    connection-test-query: select 1
---
spring:
  profiles: aws-db-test

  datasource:
    jdbcUrl: xxx
    driverClassName: com.mysql.jdbc.Driver
    username: xxx
    password: xxx
    maximum-pool-size: 5
    connection-test-query: select 1
---
spring:
  profiles: local

  datasource:
    url: xxx
    driverClassName: com.mysql.jdbc.Driver
    username: xxx
    password: xxx
    maxWait: 1000
    validationQuery: select 1
```

##7. 기존 xml 설정을 JavaConfig로 변경하기